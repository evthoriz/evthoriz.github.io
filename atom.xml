<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[yu’s blog]]></title>
  <subtitle><![CDATA[脑洞大开]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://evthoriz.github.io//"/>
  <updated>2015-09-13T11:51:10.000Z</updated>
  <id>http://evthoriz.github.io//</id>
  
  <author>
    <name><![CDATA[evtHoriz]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Pub/sub 模式中的 push 和 pull]]></title>
    <link href="http://evthoriz.github.io/2015/09/13/Pubsub%20Pattern/"/>
    <id>http://evthoriz.github.io/2015/09/13/Pubsub Pattern/</id>
    <published>2015-09-12T16:00:00.000Z</published>
    <updated>2015-09-13T11:51:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>发布／订阅模式 (Pub/sub pattern) 的定义和观察者模式 (Observer pattern) 无差。按照观察者模式的定义：通过在被观察物体上注册观测器，使得被观察物体发生特定事件时，能被所有观测器获知并作出反应。套用到发布订阅模式上，就是订阅者们订阅主题，主题上有新消息发布时，所有订阅者都能收到消息。</p>
<p>相对观察者模式来说，发布／订阅模式 是一种更加实际、针对性更强的设计模式，通常在分布式消息服务的应用场景中出现。同一个主题 (topic) 允许有多个订阅者 (subscriber)，发布者 (publisher) 会向这个主题发布消息，这个消息会被该主题的所有订阅者收到。</p>
<h2 id="Push_or_Pull">Push or Pull</h2><p>如果从观察者模式的角度来考虑，发布／订阅模式也应该使用 push 的方式通知订阅者，以达到事件发生（有该主题的消息到达）后实时响应的目的。在 Redis 中的发布／订阅模式就是遵循这一思路实现的。</p>
<p><strong>Thread Model</strong></p>
<p><img src="\img\pubsub_push.png" alt="pubsub-push"><br><a id="more"></a><br>在 push 模式中，topic（服务端） 维护一个 msg queue 用来缓存消息，一个 subscriber list 来保存所有注册的订阅者。分发线程尽快把消息从队列里取出来，并发送给订阅者。这里的优点是，消息队列维护简单，服务端只需要保存一份；实时性好，服务端不会阻塞，每次取出来都尽管写给连接着的客户端即可，无需在意订阅者的消费速度。<br>缺点是如果说订阅者的消费速度根本跟不上主题的生产速度，那么尽管服务端消息被传递出去了，客户端这边可能会产生堆积，而这意味着同一个消息会有多个拷贝在同一时间存在于整个系统中。</p>
<p><img src="\img\pubsub_pull.png" alt="pubsub-pull"></p>
<p>在 pull 模式中，服务端不主动 push 消息给客户端，而是客户端主动从服务端来拉取自己订阅的主题下的消息。这和普通的消息队列的使用场景类似。区别只不过一个消息需要被所有消费者所消费。这样做的优点是，订阅者可以根据自身消费速度决定从服务端获取消息的速度，也因此没有必要再在本地缓存消息副本。同时订阅者之间速度都互不搭界。随之而来的缺点是，服务端同一个主题下需要为每个订阅者维护一个消息队列，浪费内存。可以通过改成消息引用队列来优化，比如通过消息 id 等引用到真正的消息实体。但这么做仍然还有隐含的问题，考虑普通的消息队列，当队列中的消息数量增长过快，超过设定的内存阈值后，会选择将消息先存储到磁盘中。然后消耗掉内存里的队列后，再读取磁盘补充进内存。这在 topic 中可能出现的问题是，当其他的订阅者均以消费完内存中的所有消息，一个消费速度特别慢的订阅者会导致内存里其未消费的数据无法被清理，内存空间无法释放导致不能从磁盘中加载新数据，从而阻塞了所有其他订阅者。HornetQ 中就存在如是问题。</p>
<h2 id="总结">总结</h2><p>发布／订阅模式是一种更加具体的观察者模式变种，完成分布式系统中发布者和订阅者的解耦。对于实时性强的一般倾向于 push 方式；对于 topic 消息生产速度快的倾向于pull 方法；具体采用何种方式仍然应该按照实际业务来分析。但是无论如何，消费者的消费速度决定了消息的真实的处理速度，无论消息最终被缓存在了服务端还是客户端，这都是不变的。</p>
<h2 id="Ref-">Ref.</h2><p><a href="http://redisbook.readthedocs.org/en/latest/feature/pubsub.html" target="_blank" rel="external">Redis 设计与实现－订阅与发布</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简介">简介</h2><p>发布／订阅模式 (Pub/sub pattern) 的定义和观察者模式 (Observer pattern) 无差。按照观察者模式的定义：通过在被观察物体上注册观测器，使得被观察物体发生特定事件时，能被所有观测器获知并作出反应。套用到发布订阅模式上，就是订阅者们订阅主题，主题上有新消息发布时，所有订阅者都能收到消息。</p>
<p>相对观察者模式来说，发布／订阅模式 是一种更加实际、针对性更强的设计模式，通常在分布式消息服务的应用场景中出现。同一个主题 (topic) 允许有多个订阅者 (subscriber)，发布者 (publisher) 会向这个主题发布消息，这个消息会被该主题的所有订阅者收到。</p>
<h2 id="Push_or_Pull">Push or Pull</h2><p>如果从观察者模式的角度来考虑，发布／订阅模式也应该使用 push 的方式通知订阅者，以达到事件发生（有该主题的消息到达）后实时响应的目的。在 Redis 中的发布／订阅模式就是遵循这一思路实现的。</p>
<p><strong>Thread Model</strong></p>
<p><img src="\img\pubsub_push.png" alt="pubsub-push"><br>]]>
    
    </summary>
    
      <category term="分布式" scheme="http://evthoriz.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://evthoriz.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[covariant Array & invariant Generics]]></title>
    <link href="http://evthoriz.github.io/2015/08/24/covariant%20Array%20&%20invariant%20Generics/"/>
    <id>http://evthoriz.github.io/2015/08/24/covariant Array & invariant Generics/</id>
    <published>2015-08-23T16:00:00.000Z</published>
    <updated>2015-09-13T11:52:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="covariant_还是_invariant">covariant 还是 invariant</h2><p>按照 Liskov 替换原则，如果 S 是 T 的子类型，那么对象 T 应当可以使用对象 S 来替换。这是 OOP 里多态的基石。</p>
<p>多态大大强化了OOP语言的表达能力，可以在运行时才确定到底接受哪个子类实现。但是对于数组而言，是否应该也保留多态性呢？</p>
<p>JAVA 的数组是 covariant 的，这么做可以让数组像其他对象一样充分利用面向对象的多态特性。针对Object类型数组编写的函数可以应用于任何类型的数组上，这使得数组类库的编写成为可能。比如 <code>Arrays.equals(Object[] a1, Object[] a2)</code>。</p>
<p>而在JAVA 中泛型是 invariant 的，即使 S 是 T 的子类型，仍不能将 <code>List&lt;S&gt;</code> 看做 <code>List&lt;T&gt;</code>的子类型，为什么要这样设定呢？这么做可以将潜在的代码错误扼杀在编译期。比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">integerList.add(<span class="number">1</span>);</span><br><span class="line">List&lt;Number&gt; numberList = integerList; <span class="comment">// illegal</span></span><br><span class="line">numberList.add(<span class="number">2.0f</span>);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>这样一段代码是无法通过编译的，因为编译器会认为 <code>List&lt;Integer&gt;</code> 和 <code>List&lt;Number&gt;</code> 类型不兼容，于是自然不会将<code>numberList.add(2.0f);</code>这种错误留到运行时。</p>
<p>相反，上述代码改到数组则可以通过编译，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] integers = <span class="keyword">new</span> Integer[<span class="number">2</span>];</span><br><span class="line">integers[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">Number[] numbers = integers;</span><br><span class="line">numbers[<span class="number">1</span>] = <span class="number">2.0f</span>; <span class="comment">// runtime faliure</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>Integer[]</code> 是 <code>Number[]</code> 的子类型，这段代码可以通过编译，但是运行时会抛出 <code>ArrayStoreException</code>。</p>
<p>那么为什么数组和泛型的设定不一样呢？设计之初，考虑到多态性，数组就是 covariant 的，但现在看来这种权衡更可能被当作一个设计上的缺陷。而泛型是在JDK 5.0 之后加入的，可能是为了避免数组这种 coviriant 之后往基类数组中添加其他的子类实现这种堂而皇之的错误用法，所以泛型就设计成了 invariant 的。</p>
<p>但是既然认为 <code>List&lt;Object&gt;</code> 不是所有其他 <code>list&lt;&gt;</code> 的超类，那么是否意味着向上述数组多态的便利性就没办法实现了呢？<br>可以看 <code>java.util.Collections</code> 里的 <code>shuffle(List&lt;?&gt; list)</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">    Random rnd = r;</span><br><span class="line">    <span class="keyword">if</span> (rnd == <span class="keyword">null</span>)</span><br><span class="line">        r = rnd = <span class="keyword">new</span> Random(); <span class="comment">// harmless race.</span></span><br><span class="line">    shuffle(list, rnd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在泛型中引入了 <code>&lt;?&gt;</code> 通配符 (wildcard) 的概念，<code>List&lt;?&gt; list</code> 意味着  <strong>a list of unknow</strong>，允许匹配任意泛型类型的 List。<br><code>List&lt;?&gt; list</code> 这样的设定使得完全无法断定list里装载的对象类型，因此无论试图 set什么类型进去，编译器都不会答应的。但是可以从里面取值，毕竟即使不知道什么类型取出来总可以 upcast 成 所有类型的超类 Object。不过这对编译器和开发者都太不友好了，实际使用中通配符会搭配上下界使用，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends T&gt; list <span class="comment">// 表示 a list of the unknow type that is the subtype of T</span></span><br><span class="line">List&lt;? <span class="keyword">super</span> T&gt; list <span class="comment">// 表示 alist of the unknow type that is the supertype of T</span></span><br></pre></td></tr></table></figure>
<p>通过限定通配符的上下界，编译器检查时可以获取足够的信息来判定，从 list 取出的值与放入的值类型是否正确。用 extends 来限定上界，那么unknow type 可以是任意 T 的子类，从 list 中取出的值都可以 upcast 成 超类 T。用 super 来限定下界，那么unknow type 可以是任意 T 的超类，类型 T 就一定可以放入 list 中。</p>
<h2 id="Java_泛型的设计问题">Java 泛型的设计问题</h2><p>由于泛型是在 JAVA5 之后才加入的 feature，故它的设计不得不考虑对老版本代码的兼容，为了使原来非泛型编写的库，再引入泛型后可以无缝对接，JAVA 的设计者在泛型的实现上最终选择了使用类型擦除。这意味着，泛型在 Java 中并不是一等公民，而是一种仅在代码的编译期通过编译器做静态代码检查并在编译成字节码时在需要的地方插入类型转换的功能而已。类型擦除后编译出来的类结构部分的字节码和不使用泛型编译出来的字节码是一样的。这也很明显有这样一个问题，运行时无法得到设定的泛型类型参数信息，因为它在类结构中根本不存在。在使用泛型的 Java 库中，需要类型信息时通常需要传递 class 对象作为参数，也是因此不得已为之。</p>
<p>这里强调类结构的字节码是因为在类型擦除后，编译出来类结构以外的字节码中还是会在某个地方保存有类型信息。</p>
<h2 id="Java_泛型实例">Java 泛型实例</h2><p>下面是 5 个非常简单的泛型方法定义，擦除后都是对应的同一个方法定义，故无法互相重载。</p>
<p>第一个普通用法，Integer 的 list，故元素取出来可以放入 Integer 类型的变量 n 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bound</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    Integer n = list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 第二个是带参数类型 T 的泛型方法定义，由于类型 T 不确定，故不能放入指定了具体类型的元素，但是取出来的元素必定是T类型的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">bound</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        list.add(1); // compile failure</span></span><br><span class="line">    T n = list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 第三个是带通配符类型的泛型方法定义，由于类型未知，故不能放入指定了具体类型的元素，取出来的数据也只有 Object 类型能 hold 住。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bound</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        list.add(1); // compile failure</span></span><br><span class="line">    Object o = list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 第四个是带上界的通配符类型的泛型方法定义，由于只知道类型是上界的子类型，故不能放入任何指定了具体类型的元素，但取出来的元素肯定可以自动 upcast 成上界类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bound</span><span class="params">(List&lt;? extends Number&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        list.add(1); // compile failure</span></span><br><span class="line">    Number n = list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 第五个是带下界的通配符类型的范型方法定义，由于只知道类型是下界的超类型，故可以放入任何该下界子类型的元素，但是取出来的数据只有 Object 类型能 hold 住。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bound</span><span class="params">(List&lt;? <span class="keyword">super</span> Number&gt; list)</span> </span>&#123;</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    Object n = list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Ref-">Ref.</h2><p><a href="http://c2.com/cgi/wiki?JavaArraysBreakTypeSafety" target="_blank" rel="external">Java Arrays Break Type Safety</a></p>
<p><a href="https://www.ibm.com/developerworks/library/j-jtp01255/" target="_blank" rel="external">Java theory and practice: Generics gotchas</a></p>
<p><a href="https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html" target="_blank" rel="external">Wildcards</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="covariant_还是_invariant">covariant 还是 invariant</h2><p>按照 Liskov 替换原则，如果 S 是 T 的子类型，那么对象 T 应当可以使用对象 S 来替换。这是 OOP 里多态的基石。</p>
<p>多态大大强化了OOP语言的表达能力，可以在运行时才确定到底接受哪个子类实现。但是对于数组而言，是否应该也保留多态性呢？</p>
<p>JAVA 的数组是 covariant 的，这么做可以让数组像其他对象一样充分利用面向对象的多态特性。针对Object类型数组编写的函数可以应用于任何类型的数组上，这使得数组类库的编写成为可能。比如 <code>Arrays.equals(Object[] a1, Object[] a2)</code>。</p>
<p>而在JAVA 中泛型是 invariant 的，即使 S 是 T 的子类型，仍不能将 <code>List&lt;S&gt;</code> 看做 <code>List&lt;T&gt;</code>的子类型，为什么要这样设定呢？这么做可以将潜在的代码错误扼杀在编译期。比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">integerList.add(<span class="number">1</span>);</span><br><span class="line">List&lt;Number&gt; numberList = integerList; <span class="comment">// illegal</span></span><br><span class="line">numberList.add(<span class="number">2.0f</span>);</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="JAVA基础" scheme="http://evthoriz.github.io/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Geohash 算法完整实现]]></title>
    <link href="http://evthoriz.github.io/2015/08/05/geohash-implement/"/>
    <id>http://evthoriz.github.io/2015/08/05/geohash-implement/</id>
    <published>2015-08-04T16:00:00.000Z</published>
    <updated>2015-08-05T08:19:35.000Z</updated>
    <content type="html"><![CDATA[<p>果然欠下的债还是得还啊，今天将 GeoHash 算法完整的实现了一遍，包扩上次偷懒的 Base32 编码的实现，和计算周围8个 geohash 的实现，周围8个的计算方法可以参考我的另一篇 <a href="/2015/07/02/Geohash 算法的边界问题/">分析</a>。<br>写成了一个工具类，</p>
<h3 id="提供下列接口">提供下列接口</h3><table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>toGeoHash(double lng, double lat)<br> 根据经纬度计算 geohash，默认长度为8</td>
</tr>
<tr>
<td>String</td>
<td>toGeoHash(double lng, double lat, int level)<br> 根据经纬度转换为指定长度的 geohash</td>
</tr>
<tr>
<td>GPS</td>
<td>toGPS(String geohash)<br> 将 geohash 转换成gps，GPS 类包含经纬度两个值</td>
</tr>
<tr>
<td>List\<string\></string\></td>
<td>getRound8(String geohash)<br>根据给定的geohash计算出周围8个 geohash</td>
</tr>
</tbody>
</table>
<p>性能方面在笔记本上随便测试了一下，getRound8 在 50w 上下，其他每个接口都在百万以上。</p>
<p>代码位置：<a href="https://github.com/evthoriz/geohash-java" target="_blank" rel="external">Github</a></p>
<a id="more"></a>
<h3 id="实现中的几个注意点">实现中的几个注意点</h3><h4 id="二进制计算">二进制计算</h4><p>由于没有 bit 类型，二进制串使用了 int 数组表示。尽管 int 四子节，但相比单字节来说运算更方便。另外也没有使用 Java 提供的 <code>String toBinaryString(int i)</code> 和 <code>int parseInt(String s, int radix)</code> 这两个方法。操作 int 数组应该是最快的了。</p>
<h4 id="合并">合并</h4><p>经度 [-180, 180] 纬度 [-90, 90]</p>
<p>大于为1，设置低端边界为中间值。</p>
<p>小于为0，设置高端边界为中间值。</p>
<p>偶数位放经度 lng</p>
<p>奇数位放纬度 lat</p>
<p>从第0位开始，故先放经度。</p>
<h4 id="Base32_编码">Base32 编码</h4><p>geohash 官方使用的 Base32 字母表并非 RFC 4648 标准内定义的任何一种。故需要自己实现。</p>
<table>
<thead>
<tr>
<th>Decimal</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
</tr>
</thead>
<tbody>
<tr>
<td>Base32</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>b</td>
<td>c</td>
<td>d</td>
<td>e</td>
<td>f</td>
<td>g</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Decimal</th>
<th>16</th>
<th>17</th>
<th>18</th>
<th>19</th>
<th>20</th>
<th>21</th>
<th>22</th>
<th>23</th>
<th>24</th>
<th>25</th>
<th>26</th>
<th>27</th>
<th>28</th>
<th>29</th>
<th>30</th>
<th>31</th>
</tr>
</thead>
<tbody>
<tr>
<td>Base32</td>
<td>h</td>
<td>j</td>
<td>k</td>
<td>m</td>
<td>n</td>
<td>p</td>
<td>q</td>
<td>r</td>
<td>s</td>
<td>t</td>
<td>u</td>
<td>v</td>
<td>w</td>
<td>x</td>
<td>y</td>
<td>z</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<p>果然欠下的债还是得还啊，今天将 GeoHash 算法完整的实现了一遍，包扩上次偷懒的 Base32 编码的实现，和计算周围8个 geohash 的实现，周围8个的计算方法可以参考我的另一篇 <a href="/2015/07/02/Geohash 算法的边界问题/">分析</a>。<br>写成了一个工具类，</p>
<h3 id="提供下列接口">提供下列接口</h3><table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>toGeoHash(double lng, double lat)<br> 根据经纬度计算 geohash，默认长度为8</td>
</tr>
<tr>
<td>String</td>
<td>toGeoHash(double lng, double lat, int level)<br> 根据经纬度转换为指定长度的 geohash</td>
</tr>
<tr>
<td>GPS</td>
<td>toGPS(String geohash)<br> 将 geohash 转换成gps，GPS 类包含经纬度两个值</td>
</tr>
<tr>
<td>List\<String\></td>
<td>getRound8(String geohash)<br>根据给定的geohash计算出周围8个 geohash</td>
</tr>
</tbody>
</table>
<p>性能方面在笔记本上随便测试了一下，getRound8 在 50w 上下，其他每个接口都在百万以上。</p>
<p>代码位置：<a href="https://github.com/evthoriz/geohash-java">Github</a></p>]]>
    
    </summary>
    
      <category term="LBS" scheme="http://evthoriz.github.io/tags/LBS/"/>
    
      <category term="算法" scheme="http://evthoriz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GC root 和 Memory leak]]></title>
    <link href="http://evthoriz.github.io/2015/07/30/gc-root-and-memory-leak/"/>
    <id>http://evthoriz.github.io/2015/07/30/gc-root-and-memory-leak/</id>
    <published>2015-07-29T16:00:00.000Z</published>
    <updated>2015-07-31T08:21:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="内存泄漏？">内存泄漏？</h2><p>JVM 采用的是 tracing GC，即从根 (GC root set) 开始追踪所有可到达的对象。将不可到达的对象清除。对象清理交给 JVM 管理，除非 JVM 有 bug，不会存在内存泄漏的问题。实际使用中，大多数出现 OOM 的情形也不是 GC 的问题，而是代码不当，很多对象明明不再使用但代码里却仍然在某处维持着到它们的强引用。典型的就是不断向 static map 这种静态容器里塞东西却从不移除；还有生产者生产速度大于消费者，然后队列没有控制好上限，也一样。这类情形其实算不上内存泄漏，因为引用还在，你也可以拿到它们，仍旧可以在某处把它们释放掉。</p>
<p>但还有一种比较 tricky 的情形，代码中已经无处可以拿到这个对象的引用了，但是却无法被 GC 。<br>无法 GC 至少说明了一点，从 GC root 到对象是到可到达的，但是既然可到达，那引用是被谁持有了呢？引用存在却无处获取又是什么情况呢？</p>
<a id="more"></a>
<h2 id="关于_GC_root">关于 GC root</h2><p>首先从 GC root 说起，所谓 GC root 即一组被当作 GC 根节点的集合，tracing 正是从它们开始。那么哪些东西该被当作 GC root 呢？最容易想到的就是 JVM stack 里的数据了。每个线程创建之初都会分配一个私有的JVM stack，每个方法调用都会压入一个栈帧。栈里的某些变量，维持着到 heap 上对象的引用。因为栈里的数据正在被 thread 使用，故栈里的引用变量一定是 GC root。另外容易想到的就是方法区的静态变量了，类被加载后被放置在方法区，和类绑定的这些静态变量也极可能维持着到 heap 上对象的引用，故也属于 GC root。</p>
<p>现在来看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 新建实例，不使用</span></span><br><span class="line">                A a = <span class="keyword">new</span> A();</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码是没有问题的，变量 a 每次新建了之后就被回收掉，不再属于 root set，所以它指向的对象会被 GC。</p>
<p>然后稍微修改一下 A</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">// static List&lt;Long&gt; l = new ArrayList&lt;&gt;(100000);</span></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;A&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tl.set(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 A 里加入了 ThreadLocal 类型的静态变量，这使得 t 内部会创建出一个 ThreadLocalMap 类型的 map。<br>现在这个 map 会多一条数据，引用了 Main$A 的实例。不过仍然没有问题，每次迭代不过是更新 tl 里的 value 罢了。因为 key 是一样的就是 ThreadLocal 的实例 tl 自己。</p>
<p>tl 是静态变量，要让 tl 不同，需要想办法使得 tl 绑定的class 不是同一个。嗯，自定义类加载器就好了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> String basePath = <span class="string">"you/base/path/"</span>;</span><br><span class="line"></span><br><span class="line">CustomClassLoader() &#123;</span><br><span class="line">    <span class="keyword">super</span>(Main.class.getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String className, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    Class cls = <span class="keyword">super</span>.findLoadedClass(className);</span><br><span class="line">    <span class="keyword">if</span> (cls != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!A.class.getName().equals(className)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(className, resolve);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Path path = Paths.get(basePath + className.replace(<span class="string">'.'</span>, File.separatorChar).concat(<span class="string">".class"</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Files.readAllBytes(path);</span><br><span class="line">        cls = defineClass(className, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(cls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">        cls = <span class="keyword">super</span>.loadClass(className, resolve);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">"Could not load class: "</span> + className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再修改下 main 函数，使用自定义类加载器来加载 A。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// A a = new A();</span></span><br><span class="line">                ClassLoader custom = <span class="keyword">new</span> CustomClassLoader();</span><br><span class="line">                Class&lt;?&gt; AClass = Class.forName(A.class.getName(), <span class="keyword">true</span>, custom);</span><br><span class="line">                AClass.newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着再运行。<br>OOM了。</p>
<p>发生了什么？由于使用了自定义类加载器，且每次都用了新建的类加载器，加载出来的类A都互不相同。由于 t 不会主动处理它的 ThreadLocalMap，这样每加载一次类 A，构造一次实例，map 里都会塞进一个 &lt;新建的tl实例 , 新加载的 Main$A 的实例&gt; 这样一对数据。而由于 a 每次都被销毁，你无从通过 a 去调用 tl.remove()。这意味着只要线程不退出，它的 ThreadLocalMap 里的数据没有办法从代码的其他地方清除。后面 OOM 还能分成两种情况：如果类 A 里还有静态变量维持着到巨大对象的引用，那么可能那些巨大对象先撑满堆，OOM: heap space 先发生。如果 heap 足够大，那么由于不停的加载 ‘<strong>新</strong>’ 类，可能先发生 OOM: permGen space（注 Java8 已经移除了PermGen）。</p>
<p>说到底，t 相当于在这里扮演了一个 GC root 的角色。t 内的 ThreadLocalMap 的生命周期和 t 一样长，而这个 map 无从处理。故某种角度来说算的上是内存泄漏了。</p>
<h2 id="J2EE_里的_ClassLoader_Leak">J2EE 里的 ClassLoader Leak</h2><p>这里讨论的情形并不罕见。在 J2EE 里其实很容易出现。把这里的线程当成 web container，把这里的 ThreadLocalMap 当成 web container 里的某处 cache，把对 a 和 A 和 customClassLoader 的销毁和重建当成 redeploy。当 web 容器 redeploy 时，是期望将原来加载的 app 相关的类全部给 unload 掉，再重新加载的。但是一旦不小心在某处留下了一个引用没有被清理，那么这个引用的对象的 Class 和 ClassLoader 都无法被 unload 掉，遂导致这个 ClassLoader 加载的所有 Class 无法被 unload。这样多次的 redeploy， 很容易造成 permGen 空间不足。</p>
<h2 id="Ref-">Ref.</h2><p><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html" target="_blank" rel="external">The Structure of the Java Virtual Machine</a></p>
<p><a href="https://www.yourkit.com/docs/java/help/gc_roots.jsp" target="_blank" rel="external">GC roots</a></p>
<p><a href="https://plumbr.eu/blog/memory-leaks/what-is-a-permgen-leak" target="_blank" rel="external">What is a PermGen leak?</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="内存泄漏？">内存泄漏？</h2><p>JVM 采用的是 tracing GC，即从根 (GC root set) 开始追踪所有可到达的对象。将不可到达的对象清除。对象清理交给 JVM 管理，除非 JVM 有 bug，不会存在内存泄漏的问题。实际使用中，大多数出现 OOM 的情形也不是 GC 的问题，而是代码不当，很多对象明明不再使用但代码里却仍然在某处维持着到它们的强引用。典型的就是不断向 static map 这种静态容器里塞东西却从不移除；还有生产者生产速度大于消费者，然后队列没有控制好上限，也一样。这类情形其实算不上内存泄漏，因为引用还在，你也可以拿到它们，仍旧可以在某处把它们释放掉。</p>
<p>但还有一种比较 tricky 的情形，代码中已经无处可以拿到这个对象的引用了，但是却无法被 GC 。<br>无法 GC 至少说明了一点，从 GC root 到对象是到可到达的，但是既然可到达，那引用是被谁持有了呢？引用存在却无处获取又是什么情况呢？</p>]]>
    
    </summary>
    
      <category term="JAVA基础" scheme="http://evthoriz.github.io/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[protected 修饰符总结]]></title>
    <link href="http://evthoriz.github.io/2015/07/28/Protected-Summary/"/>
    <id>http://evthoriz.github.io/2015/07/28/Protected-Summary/</id>
    <published>2015-07-27T16:00:00.000Z</published>
    <updated>2015-07-31T08:12:29.000Z</updated>
    <content type="html"><![CDATA[<p>这两天看资料，顺便整理一下 Java 的 protected 修饰符，以免遗忘。</p>
<p>假定两个类定义在两个包中:</p>
<table>
<thead>
<tr>
<th>package</th>
<th>Class</th>
</tr>
</thead>
<tbody>
<tr>
<td>p</td>
<td>P</td>
</tr>
<tr>
<td>c</td>
<td>C extends P</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>有以下结论：</p>
<ol>
<li><p>类P 的 protected 成员方法在 包p 内可见，包外不可见。</p>
</li>
<li><p>类C 可以继承得到所有 类P 的 protected 成员方法，类C 继承得到的 protected 成员方法在 类C 内可以自由使用，但是只限于 类C 内。</p>
</li>
<li><p>类C 内无法通过 类P 访问 类P 的 protected 成员方法。</p>
</li>
<li><p>包c 内无法通过 类C 访问 类C 继承得来的 protected 成员方法。</p>
</li>
<li><p>包p 内可以通过 类C 访问 类C 继承得来的 protected 成员方法。</p>
</li>
</ol>
<p><strong>以上归纳为一点：protected 包外不可见原则。</strong></p>
<p>同时针对成员变量有效。</p>
<p>针对构造函数，首先构造函数不能继承／覆写，只能重载。然后，该原则仍旧适用，因为你无法在包外调用 类P 的构造函数。但是子类可以在构造函数内使用 super() 来用父类的 protected 构造函数（行为和继承 protected 成员方法情形相似，但构造函数是不继承的）。</p>
<p>验证代码：</p>
<p><em>package p;</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> balance = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Parent</span><span class="params">(<span class="keyword">int</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">credit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (balance &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"not enough balance"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.balance -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>package c;</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">0</span>); <span class="comment">// correct</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        credit(); <span class="comment">// 继承的方法，correct。 (2)</span></span><br><span class="line"><span class="comment">//      Parent p = new Parent(10); // compile error! 包外不可见。 (1)</span></span><br><span class="line">        Parent p = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="comment">//      p.credit(); // compile error，包外，父类的 protected 方法仍旧不可见。(1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>package c;</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//      Parent p = new Parent(200); // compile error! 包外不可见。 (1)</span></span><br><span class="line">        Parent p = <span class="keyword">new</span> Parent(); <span class="comment">// correct, public</span></span><br><span class="line"><span class="comment">//      p.credit(); // compile error! 包外不可见。 (3)</span></span><br><span class="line"></span><br><span class="line">        Child c = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="comment">//      c.credit(); // compile error! 调用的父类方法，还是属于不同的package。 (4)</span></span><br><span class="line"><span class="comment">//      Child c2 = new Child(12); // compile error! 没有带参构造函数。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>package p;</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Parent p = <span class="keyword">new</span> Parent(<span class="number">200</span>); <span class="comment">// correct, 同一个 package。 (1)</span></span><br><span class="line"><span class="comment">//      Parent p = new Parent(); // correct, public</span></span><br><span class="line">        p.credit(); <span class="comment">// correct, 同一个 package。  (1)</span></span><br><span class="line"></span><br><span class="line">        Child c = <span class="keyword">new</span> Child();</span><br><span class="line">        c.credit(); <span class="comment">// correct, 方法原本就属于这个 package (5)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>这两天看资料，顺便整理一下 Java 的 protected 修饰符，以免遗忘。</p>
<p>假定两个类定义在两个包中:</p>
<table>
<thead>
<tr>
<th>package</th>
<th>Class</th>
</tr>
</thead>
<tbody>
<tr>
<td>p</td>
<td>P</td>
</tr>
<tr>
<td>c</td>
<td>C extends P</td>
</tr>
</tbody>
</table>]]>
    
    </summary>
    
      <category term="JAVA基础" scheme="http://evthoriz.github.io/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SpringMVC 源码阅读]]></title>
    <link href="http://evthoriz.github.io/2015/07/25/SpringMVC%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://evthoriz.github.io/2015/07/25/SpringMVC 源码阅读/</id>
    <published>2015-07-24T16:00:00.000Z</published>
    <updated>2015-07-31T08:29:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="从_Servlet_开始">从 Servlet 开始</h2><p>Web container 以 Jetty 为例，初始化的时候从 web.xml 中加载配置的 servlet。这个 servlet 当然是按照 <code>javax.servlet.Servlet</code> 接口实现的。由 Jetty 的 servletHolder 维护。Jetty 在接受到请求时，根据映射关系找出符合的 servletHolder 处理，servletHolder 才使用其维护的 servlet，调用标准接口方法 <code>service</code>。</p>
<p><strong>Interface Servlet</strong></p>
<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>void</td>
<td>service(ServletRequest req, ServletResponse res)<br><em>Called by the servlet container to allow the servlet to respond to a request.</em></td>
</tr>
</tbody>
</table>
<p>和 SpringMVC 结合使用时，在 web.xml 中配置的 servlet 就是 Spring 的 <code>DispatcherServlet</code> 了。</p>
<a id="more"></a>
<p>看看 DispatcherServlet 的继承类和实现接口<br><img src="\img\springmvc-dispatcherservlet-1.png" alt="springmvc-dispatcherservlet-1"></p>
<p>可以看到 DispacherServlet 在 Spring 包里的继承关系中还有两个类 <code>FrameworkServlet</code> 和 <code>HttpServletBean</code>。并由 HttpServletBean 来继承 <code>javax.servlet</code> 库里的 <code>HttpServlet</code> 来最终完成对标准接口的实现和扩展。</p>
<p>FrameworkServlet 的角色的官方说明：</p>
<blockquote>
<p>Base servlet for Spring’s web framework. Provides integration with a Spring application context, in a JavaBean-based overall solution.</p>
</blockquote>
<p>FrameworkServlet 即我们通常定义的基类，但它只有 DispatcherServlet 一个子类，故一个基本作用就是处理周边工作。同时它还是一个抽象类，唯一一个抽象方法是 <code>doService</code> 。由于间接继承了 HttpServlet，故可以覆写所有的 doGet、doPost 系列的方法，并将处理逻辑统一交给方法 <code>processRequest</code>处理。processRequest 稍微处理了下 request 就丢给 doService 了。</p>
<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>protected abstract void</td>
<td>doService(HttpServletRequest request, HttpServletResponse response) <br> <em>Subclasses must implement this method to do the work of request handling, receiving a centralized callback for GET, POST, PUT and DELETE.</em></td>
</tr>
</tbody>
</table>
<p>这个方法，只要 debug 过 Spring 的 DispatcherServlet 就一定很熟悉了。    <code>doDispatch</code>方法就是由它调用的。</p>
<p>梳理一下调用链</p>
<ol>
<li>service —&gt; 2. doGet/…/doPost —&gt; 3.processRequst —&gt; 4. doService —&gt; 5. doDispatch</li>
</ol>
<p>1 和 2 其实是 HttpServlet 里的标准方法，但是 HttpServlet 里没有对 HTTP PATCH 方法进行支持，故 1 在 FrameworkServlet 里被覆写，加入了对 PATCH 方法的处理。2 很自然的是在 FrameworkServlet 里重写的。3 是Framework里的处理。4 是由 FrameworkServlet 定义的抽象方法，由 DispatcherServlet 实现。5 就是 DispatcherServlet 的重头戏了。</p>
<p>注意这个调用链的参数一直都是 <code>(HttpServletRequest req, HttpServletResponse resp)</code></p>
<p>因此可以看出只是逻辑转移，增加控制。</p>
<p>FrameworkServlet 究竟做了哪些周边工作呢？</p>
<ul>
<li>为每个 servlet 管理一个 <code>WebApplicationContext</code> 实例，servlet 的配置项由 servlet 命名空间里的 beans 指定。</li>
<li>发布请求处理产生的事件，无论这个请求是否被成功处理。</li>
</ul>
<p>功能一的一部分是由它的父类 <code>HttpServletBean</code>参与完成的。这个类是个没有抽象方法的抽象类（就是不让你实例化），它很单纯，就是将 web.xml 里的初始化参数读进来并转换成 bean，同时应用子类（此处即 FrameworkServlet ）的初始化。然后 ApplicationContext 的概念是放在 FrameworkServlet 的，它的初始化即将 servlet的配置加载进 context 中。将 context 和 servlet 维护好。</p>
<p>功能二是当请求被 DispatcherServlet 处理完之后，在 processRequest 的最后发送一个事件给所有监听器，监听器会做好后续工作，失败，异常，context 变动等等。</p>
<p><strong>到这里，可以看出抽象出 FrameworkServlet 这个类的作用了，和它的命名一样，继承和覆写 Servlet 功能，配好环境（上下文），并控制框架的整体处理逻辑。</strong></p>
<h2 id="进入_DispatcherServlet">进入 DispatcherServlet</h2><p>这个类可以说是 SpringMVC 的枢纽，通过它，Controller、Model、View 得到了统一调度，和谐运作。它们的逻辑关系，就在熟悉的 <code>doDispatch</code>方法里了。</p>
<p>和他们密切相关的几个类是：</p>
<ul>
<li>C: HandlerMapping、HandlerAdaptor、HandlerInterceptor</li>
<li>M: ModelMap</li>
<li>V: View、ViewResolver</li>
</ul>
<p>还有大家熟知的 ModelAndView 里，维护的就是一个 ModelMap 和一个 View。</p>
<p>简单解释下各个类的作用。</p>
<p>HandlerMapping 通过映射关系，找到对应的 Handler。</p>
<p>HandlerAdaptor 是一个 handler 的适配器，维护了一个 Object 类型的 handler。它的存在，为无限类型的 handler 扩展提供了可能。</p>
<p>HandlerInterceptor 是一个接口， 用于 handler 的拦截器，会在 handler 处理的前，后，结束时调用。具体拦截到之后的处理逻辑交给用户自定义。</p>
<p>ModelMap 是一个 LinkedHashMap 存储各种属性（处理结果）的键值对。</p>
<p>ViewResolver 是一个接口，作用是根据 viewName 获取对应的 View。View 也定义成了接口，提供 render 方法。不同的 ViewResolver 会根据 viewName 找到对应的 View 实现类，把 view render 到 response 里。<strong>这么做的好处是可以支持无限种类的视图技术，以及它们的组合使用。</strong></p>
<p>下面是 doDispatch 的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    <span class="comment">// HandlerExecutionChain 是一个包含了 Handler 和 InterceptorList 的执行链。</span></span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 标记请求是否转换成了处理 multipart 的请求</span></span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 放一个 asyncManager 到 request 中</span></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过一个 multipartResolver 检测并尝试转换</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            <span class="comment">// 是否真的转换</span></span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过 handlerMappings 找到对应的 handler 和 interceptors 并返回执行链</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为这个 handler 找到对应的 HandlerAdaptor</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查 lastModified，没有新改动就返回</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 启用执行链里的所有拦截器的预处理，未通过则返回</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 用 handlerAdaptor 来处理请求并返回 ModelAndView</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 看 handler 是否是异步处理的</span></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            applyDefaultViewName(request, mv);</span><br><span class="line">            <span class="comment">// 启用执行链里的所有拦截器的后处理。</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理 handler 的执行结果，并渲染 view 到响应中，有异常则会渲染一个 error view。同时启用执行链里所有拦截器的完结处理。</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="comment">// 在异常发生时，启用执行链里所有拦截器的完结处理。</span></span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">        <span class="comment">// 在错误发生时，启用执行链里所有拦截器的完结处理，总之就是要把拦截器里定义的完结处理给做完。</span></span><br><span class="line">        triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// 如果请求是异步处理的，应用的异步拦截器的后处理。</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 释放 multiPartRequest 持有的所有资源。</span></span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面用到的对象，都在<code>initStrategies</code>这个函数内初始化了。初始化逻辑都差不多，从上下文中根据 Key 获取 bean，赋值给 dispatcherServlet 的成员变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">	initMultipartResolver(context);</span><br><span class="line">	initLocaleResolver(context);</span><br><span class="line">	initThemeResolver(context);</span><br><span class="line">	initHandlerMappings(context);</span><br><span class="line">	initHandlerAdapters(context);</span><br><span class="line">	initHandlerExceptionResolvers(context);</span><br><span class="line">	initRequestToViewNameTranslator(context);</span><br><span class="line">	initViewResolvers(context);</span><br><span class="line">	initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看下 initMultipartResolver 里初始化的代码。context 里的 bean 均是 FrameworkServlet 里 initWebApplicationContext() 加载进去的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class);</span><br></pre></td></tr></table></figure>
<p>总的来说，看一下 SpringMVC 的源码还是比较有收获的。可以看到依托于 Spring 的依赖注入之上，SpringMVC 本身结构很清晰，扩展性强。</p>
<h2 id="Ref-">Ref.</h2><p><a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html" target="_blank" rel="external">Web MVC framework</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="从_Servlet_开始">从 Servlet 开始</h2><p>Web container 以 Jetty 为例，初始化的时候从 web.xml 中加载配置的 servlet。这个 servlet 当然是按照 <code>javax.servlet.Servlet</code> 接口实现的。由 Jetty 的 servletHolder 维护。Jetty 在接受到请求时，根据映射关系找出符合的 servletHolder 处理，servletHolder 才使用其维护的 servlet，调用标准接口方法 <code>service</code>。</p>
<p><strong>Interface Servlet</strong></p>
<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>void</td>
<td>service(ServletRequest req, ServletResponse res)<br><em>Called by the servlet container to allow the servlet to respond to a request.</em></td>
</tr>
</tbody>
</table>
<p>和 SpringMVC 结合使用时，在 web.xml 中配置的 servlet 就是 Spring 的 <code>DispatcherServlet</code> 了。</p>]]>
    
    </summary>
    
      <category term="Spring" scheme="http://evthoriz.github.io/tags/Spring/"/>
    
      <category term="框架" scheme="http://evthoriz.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java8 lambda 简明要义]]></title>
    <link href="http://evthoriz.github.io/2015/07/20/Java8-lambda-brief/"/>
    <id>http://evthoriz.github.io/2015/07/20/Java8-lambda-brief/</id>
    <published>2015-07-19T16:00:00.000Z</published>
    <updated>2015-07-21T06:14:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="新增类型？">新增类型？</h2><p>Java8 并不新增函数类型，而是在原本使用函数式接口实现类的地方，给你提供了使用 lambda 表达式的替代方案。</p>
<p>上面这句话具体来讲就是，你还是没有办法在定义函数时，用函数作为参数，但是你可以用一个函数式接口作为参数。对于使用函数式接口作为参数的地方，你可以不必像以前一样新建一个它的实例来使用，而是可以用一个 lambda 表达式直接将方法写出来。至于函数式接口是什么，就是只包含一个方法的接口而已。</p>
<a id="more"></a>
<p>举个例子：原先我们使用线程是这样定义的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">"Evthoriz"</span>;</span><br><span class="line">Thread th = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>由于 Runnable 是函数式接口（只有一个 run 方法），故可以直接使用 lambda 表达式来代替</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread th = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello, "</span> + name);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当然也可以先用 lambda 表达式实现函数式接口</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = <span class="function"><span class="params">()</span> -&gt;</span> &#123;System.out.println(<span class="string">"Hello, "</span> + name)&#125;;</span><br><span class="line">Thread th = <span class="keyword">new</span> Thread(r);</span><br></pre></td></tr></table></figure>
<h2 id="Lambda_表达式">Lambda 表达式</h2><h4 id="结构">结构</h4><p>lambda 表达式的一般结构为</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">()</span> -&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>圆括号里边是方法参数，无参数则不填。花括号里边则为函数结构体，当不引起歧义时，括号均可省略。<br>故上面的 Runnable 接口可以这么定义</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread th = <span class="keyword">new</span> Thread<span class="function"><span class="params">(() -&gt; System.out.println(<span class="string">"Hello, "</span> + name))</span>;</span></span><br></pre></td></tr></table></figure>
<p>由于类型推导系统的存在，有参数时，参数类型也可以省略，例如</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; cp = <span class="function"><span class="params">(x, y)</span> -&gt;</span> x &gt; y ? <span class="number">1</span> : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h4 id="作用域">作用域</h4><p>关于作用域，在理解匿名内部类作用域规则的基础之上，只需要记住一点</p>
<blockquote>
<p>外部类中的变量到了 lambda 表达式中，其语义不变，包括 <strong>this</strong>。</p>
</blockquote>
<p>PS: 在 Java 8 以前，匿名内部类里要引用外部变量时因为数据一致性的缘故必须先将该外部变量声明成 final 才行。在 Java 8 中限制放宽，假如该变量不做修改，那么不再需要显示的指定 final 了。但是如果在 lambda 表达式中尝试修改这个变量的 <strong>值</strong>，那么编译一定还是通过不了的。</p>
<h2 id="Pipeline_编程">Pipeline 编程</h2><p>在 JDK1.8 中，Collection 接口新增了 stream() 和 parallelStream() 方法。想要使用 pipeline 范式需要先将 collection stream 化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; l1 = ...;</span><br><span class="line">List&lt;Integer&gt; l2 = l1.stream()</span><br><span class="line">        .filter(i -&gt; i &gt; <span class="number">0</span>)</span><br><span class="line">        .map(i -&gt; i + <span class="number">1</span>)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p><em>过滤出正整数，然后每个给每个数加一。最后收集起来转换为 List 返回。</em></p>
<p>filter \ map \ collect 这几个是 stream 接口内定义的方法，既然能接受 lambda 表达式作为参数也能很容易推断出这几个方法的参数定义一定为函数式接口类型。还有哪些方法可以到 <code>java.util.stream</code> 这个接口里查看。Java8 新增的函数式接口可以参看包 <code>java.util.function</code>。</p>
<h2 id="Ref-">Ref.</h2><p><a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html" target="_blank" rel="external">State of the Lambda</a></p>
<p><a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-libraries-final.html" target="_blank" rel="external">State of the Lambda: Libraries Edition</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="新增类型？">新增类型？</h2><p>Java8 并不新增函数类型，而是在原本使用函数式接口实现类的地方，给你提供了使用 lambda 表达式的替代方案。</p>
<p>上面这句话具体来讲就是，你还是没有办法在定义函数时，用函数作为参数，但是你可以用一个函数式接口作为参数。对于使用函数式接口作为参数的地方，你可以不必像以前一样新建一个它的实例来使用，而是可以用一个 lambda 表达式直接将方法写出来。至于函数式接口是什么，就是只包含一个方法的接口而已。</p>]]>
    
    </summary>
    
      <category term="JAVA基础" scheme="http://evthoriz.github.io/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数式编程" scheme="http://evthoriz.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从 String 讲 immutable 的重要性]]></title>
    <link href="http://evthoriz.github.io/2015/07/13/String-immutable/"/>
    <id>http://evthoriz.github.io/2015/07/13/String-immutable/</id>
    <published>2015-07-12T16:00:00.000Z</published>
    <updated>2015-07-21T06:10:55.000Z</updated>
    <content type="html"><![CDATA[<p>当我们说某个对象是 immutable 的时候，即是指它被创建出来后，就不会再改变了。也意味着你可以随意使用，并且不用担心线程安全的问题。当然我们很乐意对象是不可变的，它可以让我们少耗点脑细胞。那么凭什么它就是不可变的呢？要是有人不遵循约定修改了它怎么办？</p>
<p>让一个对象不可变当然得花点力气，比如最常见的做法是：</p>
<ul>
<li>定义 class 时，用 final 修饰符，以防止类被继承。</li>
<li>对所有成员变量使用限定符 private。</li>
<li>不提供修改成员变量的 public 方法。</li>
</ul>
<a id="more"></a>
<p>看起来不错。实际上 String 类型就是这么着定义的。那么为什么 String 要设计成 immutable 的呢？一个原因是因为它太常用了（实际上 Java 里的一些基础类型的包装类也都是被设计成 immutable 的）。在线程间共享不会造成冲突，从而完全不用考虑锁的问题。另外它也涉及到了一个安全问题，比如 String 类型经常被当作 HashMap 的 key 使用，打开 socket 时的 host ，甚至 classLoader 加载类时用的类名。很多系统调用都是使用字符串作为参数的，一旦在调用过程中发生改变可能会发生意想不到的情况。</p>
<p>举个例子：让某个对象打开并读取一个文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String origion = <span class="string">"testdata/sunshine.txt"</span>;</span><br><span class="line">    Someone someone = <span class="keyword">new</span> Someone();</span><br><span class="line">    someone.tryOpenFile(origion);</span><br><span class="line">    <span class="comment">//doModify(origion);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Someone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryOpenFile</span><span class="params">(String origion)</span> </span>&#123;</span><br><span class="line">        Thread fileOpener = <span class="keyword">new</span> Thread(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Someone - I'm gonna open the file: "</span> + origion);</span><br><span class="line">                        File f = <span class="keyword">new</span> File(origion);</span><br><span class="line">                        doSomeBusyTask();</span><br><span class="line">                        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(f));</span><br><span class="line">                        System.out.println(br.readLine());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;...&#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        fileOpener.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我把 <code>doModify</code> 注释掉时，程序正常运行，按照期望打印出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Someone - I&#39;m gonna open the file: testdata/sunshine.txt&#10;Today is a sunny day, isn&#39;t it ?</span><br></pre></td></tr></table></figure>
<p>但是当我把修改的代码打开，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doModify</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Field v = str.getClass().getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        v.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        v.set(str, <span class="string">"testdata/cloud.txt"</span>.toCharArray());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用反射强行修改 <em>origion</em> 的值之后，毫不知情的 <em>someone</em> 仍以为自己打开的是正确的文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Someone - I&#39;m gonna open the file: testdata/sunshine.txt&#10;Should I take the umbrella with me today ?</span><br></pre></td></tr></table></figure>
<p>这里读取代码中的 <code>doSomeBusyTask</code> 实际只是让线程 <code>sleep(1)</code> 而已。前一毫秒 someone 刚看到文件名是正确的，后一毫秒就被人修改了，这种事情太可怕了（所以对于 immutable 的对象请不要作死用什么 tricks 去修改它，除非你能确保它产生影响的范围）。</p>
<p>另外，有些字符串存放在常量池中，有些则是创建在堆里的。但是无论是堆里还是常量池里，String 都是 immutable 的，请不要修改它。</p>
<h2 id="Ref-">Ref.</h2><p><a href="http://www.artima.com/intv/gosling313.html" target="_blank" rel="external">Immutables - James Gosling</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>当我们说某个对象是 immutable 的时候，即是指它被创建出来后，就不会再改变了。也意味着你可以随意使用，并且不用担心线程安全的问题。当然我们很乐意对象是不可变的，它可以让我们少耗点脑细胞。那么凭什么它就是不可变的呢？要是有人不遵循约定修改了它怎么办？</p>
<p>让一个对象不可变当然得花点力气，比如最常见的做法是：</p>
<ul>
<li>定义 class 时，用 final 修饰符，以防止类被继承。</li>
<li>对所有成员变量使用限定符 private。</li>
<li>不提供修改成员变量的 public 方法。</li>
</ul>]]>
    
    </summary>
    
      <category term="JAVA基础" scheme="http://evthoriz.github.io/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Collection Pipeline ［译］]]></title>
    <link href="http://evthoriz.github.io/2015/07/11/Collection-Pipeline/"/>
    <id>http://evthoriz.github.io/2015/07/11/Collection-Pipeline/</id>
    <published>2015-07-10T16:00:00.000Z</published>
    <updated>2015-07-12T03:55:56.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这篇文章讲管道编程，深入浅出，推荐阅读。翻译过程中，在可能造成误解的名词上都保留了英文。</p>
</blockquote>
<p><strong>原文作者：Martin Fowler</strong></p>
<p>Collection pipelines 是一种编程范式，通过把一个操作的输出当作下个操作的输入来把计算组织成序列型的操作。（常用的操作是 filter，map，和 reduce。）这种范式在函数式编程中很普通，也存在于支持 lambda 的面向对象语言中。这篇文章将用一些例子来描述这种范式时如何形成 pipeline 的，同时也是给不熟悉这种范式的同学的一个介绍，也希望能帮助人们理解当中的核心概念，在不同语言间切换时能够触类旁通。</p>
<p>Collection pipeline 是最常见最舒服的范式之一了。比如 unix 命令行中，更好的面向对象语言中，还有最近引人瞩目的函数是语言中都有出现。不同的环境下或多或少会有些不同，同一个操作有不同的命名等，但是一旦你熟悉了这个范式，那么你一定会欲罢不能的。</p>
<a id="more"></a>
<h2 id="初次见面">初次见面</h2><p>最初遇到是我接触 Unix 时。比如将设我想要找到所有在文本中出现了 “nosql” 的 bliki entries。我可以使用 grep 命令。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -l &#39;nosql&#39; bliki/entries</span><br></pre></td></tr></table></figure>
<p>然后我可能想要知道每个 entry 里包含几个单词</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -l &#39;nosql&#39; bliki/entries/* | xargs wc -w</span><br></pre></td></tr></table></figure>
<p>接着我可能希望把他们按照单词数量排序</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -l &#39;nosql&#39; bliki/entries/* | xargs wc -w | sort -nr</span><br></pre></td></tr></table></figure>
<p>然后我只要打印出前三个</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -l &#39;nosql&#39; bliki/entries/* | xargs wc -w | sort -nr | head -4 | tail -3</span><br></pre></td></tr></table></figure>
<p>和其他环境的命令行相比这个真是相当强大了。</p>
<p>后来我在使用 Smalltalk 的时候遇到了一样的范式。假设我有一个 article 对象的集合（在 someArticles 中），其中每个都有一个 tag 集合和一个单词数量。我可以这样选出那些包含了 #nosql tag 的文章：</p>
<figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someArticles <span class="method">select:</span> [ :each | each tags <span class="method">includes:</span> <span class="symbol">#nosql</span>]</span><br></pre></td></tr></table></figure>
<p>select 方法只用到一个参数，一个 Lambda 表达式（通过一对方括号定义，在 smalltalk 中则被称为一个 “block”），这个 Lambda 定义了一个 boolean 函数。它会遍历 someArticles 里的所有元素，并返回只有 lambda 判定为 true 的那些 article 集合。</p>
<p>要把结果排序，只需要这样扩展：</p>
<figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(someArticles</span><br><span class="line">    <span class="method">select:</span> [ :each | each tags <span class="method">includes:</span> <span class="symbol">#nosql</span>])</span><br><span class="line">    <span class="method">sortBy:</span> [ :a :b | a words &gt; b words]</span><br></pre></td></tr></table></figure>
<p>sortBy 方法也是以 lambda 作为参数的方法，这次代码的作用是排序那些元素。像 select 方法一样，返回的是是一个集合，因此我还能让 pipeline 继续下去：</p>
<figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">((someArticles</span><br><span class="line">    <span class="method">select:</span> [ :each | each tags <span class="method">includes:</span> <span class="symbol">#nosql</span>])</span><br><span class="line">    <span class="method">sortBy:</span> [ :a :b | a words &gt; b words])</span><br><span class="line">    <span class="method">copyForm:</span> <span class="number">1</span> <span class="method">to:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>和 unix pipeline 的核心相似点是每个参与的方法 (select, sortBy, copyFrom) 都是操作一个记录的集合并且返回一个记录的集合。在 unix 中，这个集合是流式的，那些记录一行一行的存在于流中，在 Smalltalk 中，这个集合时一些对象，但是概念是一样的。</p>
<p>最近我也用了不少 Ruby，它的语法写起 collection pipeline 来更加方便，因为我不需要老是把上一个 pipeline 阶段用括号括起来。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .select&#123;|a| a.tags.<span class="keyword">include</span>?(<span class="symbol">:nosql</span>)&#125;</span><br><span class="line">    .sort_by&#123;|a| a.words&#125;</span><br><span class="line">    .take(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>将 collection pipeline 写成方法链的形式在面向对象的语言中是一种非常自然的方式。但是用函数嵌套也是能够做到的。</p>
<p>回头看看一些基本概念，我们看看在 common lisp 中如何建立这样一个相似的 pipeline。我可以把每一篇文章存在一个叫 articles 的数据结构中，这样我就能通过函数比如 article-words 和 article-tags 来获取它的属性了。函数 some-articles 返回最早的用来作为初始值的那些文章。</p>
<p>第一步是选择 nosql 的 articles。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">remove-if-not</span></span><br><span class="line">    <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">member</span> <span class="quoted">'nosql</span> <span class="list">(<span class="keyword">article-tags</span> x)</span>)</span>)</span></span><br><span class="line">    <span class="list">(<span class="keyword">some-articles</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>用 Smalltalk 和 Ruby 里的那个例子，我使用了函数 remove-if-not 来同时处理列表和 lambda 。然后我们继续扩展，增加排序功能，还是用一个 lambda：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">sort</span></span><br><span class="line">    <span class="list">(<span class="keyword">remove-if-not</span></span><br><span class="line">        <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">member</span> <span class="quoted">'nosql</span> <span class="list">(<span class="keyword">articles-tags</span> x)</span>)</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">some-articles</span>)</span>)</span></span><br><span class="line">    <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">a</span> b)</span> <span class="list">(<span class="keyword">&gt;</span> <span class="list">(<span class="keyword">article-words</span> a)</span> <span class="list">(<span class="keyword">article-words</span> b)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>然后是选择 top 3，使用 subseq：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">subseq</span></span><br><span class="line">    <span class="list">(<span class="keyword">sort</span></span><br><span class="line">        <span class="list">(<span class="keyword">remove-if-not</span></span><br><span class="line">            <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">member</span></span> <span class="variable">'nosql</span> <span class="list">(<span class="keyword">article-taggs</span> x)</span>)</span>)</span></span><br><span class="line">            <span class="list">(<span class="keyword">some-articles</span>)</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">a</span> b)</span> <span class="list">(<span class="keyword"><span class="built_in">&gt;</span></span> <span class="list">(<span class="keyword">article-words</span> a)</span> <span class="list">(<span class="keyword">article-words</span> b)</span>)</span>)</span>)</span></span><br><span class="line"><span class="number">0</span> <span class="number">3</span>)</span></span><br></pre></td></tr></table></figure>
<p>pipline 就是这样了，它是如此优美的一步一步建立起来的。然而问题是，当你第一眼看到这完整的表达式时，对你来说，它的 pipeline 的本质清晰么。unix pipeline 和 smalltalk/ruby pipeline 的函数是有一个线性的顺序的，它的顺序和它的执行顺序一致。你可以很容易就看穿数据是如何从左上角开始逐个的应用那些 fliter 到达底部的。Lisp 使用了嵌套函数的方式，因此你不得不从最内层开始往外阅读。</p>
<p>近代 lisp 方言，Clojure 避免了这个问题，可以写成如下形式：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">-&gt;&gt;</span></span> <span class="list">(<span class="keyword">articles</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">filter</span></span> #<span class="list">(<span class="keyword">some</span> #<span class="collection">&#123;<span class="attribute">:nosql</span>&#125;</span> <span class="list">(<span class="attribute">:tags</span> %)</span>)</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">sort-by</span></span> <span class="attribute">:words</span> &gt;)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">take</span></span> <span class="number">3</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>符号 “-&gt;&gt;” 是一个 threading macro，它使用了 lisp 强大的宏 (macro) 能力来将每个表达式的值串到下一个表达式上。 在你的库中遵循该约束，你就能将一系列的嵌套函数给转换成线性的 pipeline。</p>
<p>最近时常能听到函数式语言的粉丝们夸赞 collection pipeline，说它是面向对象语言不具有的强大特性。作为一个老 smalltalk 程序员，我实在是有些觉得这些争论无聊的很，因为在 smalltalk 的使用者老早就到处在用了。之所以人们会有这样的误解是因为流行的面向对象语言比如 C++, Java, C# 没有继承 smalltalk 对 lambda 的使用，故而也没有很多操作集合的方法来支持 pipeline 范式。结果就是对很多OO程序员来说，完全不了解 collection pipeline。但是像我一样的 smalltalk 程序员转型成 Java 程序员时，对于 Java 缺少这个特性是非常不爽的。有很多人尝试利用 Java 里可以用的东西去建造一个 collection pipeline；毕竟，对于 OOer 来说，一个 function 仅仅是一个带有方法的类罢了。但是生成的代码确实一团乱麻，就算是个中高手也不得不放弃了。Ruby 对 pipeline 优良的支持是我从 2000 年左右开始使用它的主要原因。 Smalltalk 里的好东西真是让人怀念啊。</p>
<p>最近 lambda 表达式逐渐摆脱了作为一种高级特性且基本不用的名声。主流语言如 C#，好几年前就已经支持它，甚至连 Java 最后也支持了。因此现在 collection pipeline 说不定又能出现在众多语言中了。</p>
<h2 id="定义_Collection_Pipeline">定义 Collection Pipeline</h2><p>我把 Collection Pipeline 当作一种模块化和组合化软件的范式。像大多数范式一样，它经常出现，但看上去却好像又变了个模样。不过，只要你掌握了这范式底层的思想，那你在新环境中也是能够马上认出它的。</p>
<p>Collection pipeline 会陈列出一系列的操作，它们互相传递集合。每个操作都是以一个集合作为输入，并且生出另一个集合（除了最后一个操作，可能作为终结只生成一个值了）。每个独立的操作都很简单，但是把它们串起来可以产生复杂的行为，就像你在现实生活中把管道互相插起来一样。</p>
<p>Collection Pipeline 是 Pipes and Filters 模式的一种特例。Pipes and Filters 里的 filter 对应 Collection Pipeline 里的操作 (operation)，我会用 operation 而非 filter，因为 filter 不过是众多 operation 之一罢了。另一方面，collection pipeline 是一种特别但是通用的组合高阶的处理顺序数据结构的函数的方案。</p>
<p>操作 (operations) 和操作间传递的集合 (collections)，在不同的语境中有不同的形式。</p>
<p>在 Unix 中，collection 是一个包含多行的文本文件。每一行包含多个值，通过空格分隔。每个值的含义由它的顺序决定。operations 是 unix 进程，collections 则由 pipeline 操作符组合起来。pipeline 操作符用上一个处理的标准输出作为下一个的标准输入。</p>
<p>在面向对象的语言中，collections 是一个集合类 (list, array, set, etc)。集合里的所有对象就是 collection 里的项，这些对象可能也是集合或者包含更多的集合。operations 则是定义在集合类里的方法 － 通常是定义在高层的父类里的。 operations 则是通过一个方法链组合起来的。</p>
<p>在函数式语言中，collections 和面向对象语言中的 collections 差不多。然而不像面向对象里，item 是对象，函数式里，item 是集合范型本身，比如会用一个 hashmap 。顶层集合的元素可能是集合本身，并且 hashmap 的元素也可能是集合 － 所以像面向对象的例子那样我们可以组合出任意层的复杂结构。operations 就是 functions ，它们可以嵌套组合，也可以通过一个能够线性表达的操作符来组合，就像 Clojure 的剪头操作符一样。</p>
<p>这个范型在其他地方也有出现。当关系型模型 (relational model) 最初定义的时候，提出了关系关系代数 (relational algebra)，你可以理解为一种 collection pipeline，中间的集合通过关系约束。但是 SQL 并没有使用 pipeline 方式，而是通过了更像是 comprehensions 的途径（这个后面讨论）。</p>
<p>像这样使用一系列的变换的观念是一种常见的组织程序结构的方式 － 是 Pipes and Filter 构建模式的成功。</p>
<p>编译器通常是这样工作的，从源代码，到句法树，经过各种优化，然后生成输出的代码。不同的是 collection pipeline 在不同阶段间传递的是数据结构时是集合，因而产生一些特定的操作通用的 pipeline 的 operations。</p>
<h2 id="探索更多的_pipelines_和_operations">探索更多的 pipelines 和 operations</h2><p>上面用到例子只设计了一些通用的 operation，现在我们来看看更多的例子。我会用 ruby 来讲解，因为最近用的比较多。但是其他支持这种范式语言一样可以写出一样的 pipeline 。</p>
<h4 id="Getting_total_word_counts_(map_and_reduce)">Getting total word counts (map and reduce)</h4><p><img src="\img\pipeline-example-1.png" alt="example-1"></p>
<p>最终要的两种 pipeline operation 可以用一个很简单的任务来解释：如何获取列表里所有文章的单词个数。第一个 operation 是 <strong>map</strong>，它会返回一个集合，这些集合里的元素是通过将所有输入元素应用 lambda 表达式计算出来的。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map&#123;|i| i*i&#125; <span class="comment"># =&gt; [1, 4, 9]</span></span><br></pre></td></tr></table></figure>
<p>因此假如我们使用这个方法，那么就能将文章列表转换成每一篇文章的单词数的列表了。然后，我们就可以应用另一个 operation 了：<strong>reduce</strong>。reduce 可以将一个输入集合转变为一个单一输出。这种功能的函数经常被称为 reduction。Reductions 经常减到剩一个值，这个通常是在 collectin pipeline 的最后一步发生。Ruby 里一般的 reduce 函数会用拥有两个变量的 lambda 表达式作为参数。一个变量是元素，另一个是累计器。reduction 中每一步都会将累计器的值设置为新元素和 lambda 的运算结果。可以像这样对列表求和：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce&#123;|acc, each| acc + each&#125; <span class="comment"># =&gt; 6</span></span><br></pre></td></tr></table></figure>
<p>有了这两种 operation，计算单词总数不过是两步 pipeline 而已：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .map&#123;|a| a.words&#125;</span><br><span class="line">    .reduce&#123;|acc, w| acc + w&#125;</span><br></pre></td></tr></table></figure>
<p>第一步 map 是将一个文章列表转换成了单词数列表。第二步对单词列表做了一次 reduction ，得到一个和。</p>
<p>提一下，构建 collection pipeline 时有多种方式来表达函数，可以用 lambda 表达式，也可以用函数名。用 clojure 来写这个 pipeline 是这样的：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">-&gt;&gt;</span></span> <span class="list">(<span class="keyword">articles</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">map</span></span> <span class="attribute">:words</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">reduce</span></span> +)</span>)</span></span><br></pre></td></tr></table></figure>
<p>在这个例子里只需要函数名就可以了。传递给 map 的函数会对所有输入集合的元素做运算， reduce 则作用于每个元素和累计器。在 ruby 里也可以这么做，这边 words 是一个定义在 collection 里的方法。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .<span class="function"><span class="title">map</span><span class="params">(&amp;:words)</span></span></span><br><span class="line">    .<span class="function"><span class="title">reduce</span><span class="params">(:+)</span></span></span><br></pre></td></tr></table></figure>
<p>一般来说使用函数名会更加简短些，但这样你只能调用每个对象里的简单方法。使用 lambda 能为你使用复杂句法时提供更多灵活性。用 ruby 时我一般用 lambda 多些，用 clojure 则能用函数名就用。用哪种都可以。</p>
<h4 id="获取每种_type_的_articles_的数量">获取每种 type 的 articles 的数量</h4><p><img src="\img\pipeline-example-2.png" alt="example-2"></p>
<p>下一个例子，看看每种 type 的 articles 有多少。输出应该是一个 hashmap，key 为 type ，value 为 对应类型的 article 的数量。</p>
<p>首先需要将 articles 按照 type 分组。这里能用上的操作符 (operator) 叫做 group-by。这个操作会将元素放进 hash 表中，用提供的代码处理这个元素得到的结果作为索引。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .group_by &#123;|a| a.type&#125;</span><br></pre></td></tr></table></figure>
<p>现在需要做的是取得每组 articles 的数量。这对于 map 来说太简单了，只要对每个元素运行一下 count 就可以了。但是复杂的是需要返回的数据包括：分组名称和数量。还有一个相干的问题是，前面的例子里 map 的参数都是列表，现在 group-by 出来的是 hashmap。</p>
<p>对于collection pipeline 来说，这种情况是很常见的。我们传递的 collections 可能是 list 也有可能是 hash。我们应当学会如何轻易的转换两者。技巧是，将 hash 当作 pair 的 list － 每一个 pair 包括 key 和对应的 value。当然不同语言里 hash 里的元素如何展现可能有所不同，但是一个通用的方法是将每个 hash 元素当成一个二元数组：[key, value]。</p>
<p>Ruby 就是这么做的，并且它提供了一个 to_h 方法来方便我们把 pair 的数组转换为 hash。因此我们可以这样应用 map：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .group_by &#123;|a| a.type&#125;</span><br><span class="line">    .map &#123;|pair| [pair[<span class="number">0</span>], pair[<span class="number">1</span>].size]&#125;</span><br><span class="line">    .to_h</span><br></pre></td></tr></table></figure>
<p>在 collection pipeline 里，hash 和 array 之间这样转换是很常见的。用 array 的索引来获取 pair 不太自然，因此 ruby 允许我们直接把 pair 解构成两个变量。像这样：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .group_by &#123;|a| a.type&#125;</span><br><span class="line">    .map &#123;|key, value| [key, value.size]&#125;</span><br><span class="line">    .to_h</span><br></pre></td></tr></table></figure>
<p>解构函数式编程语言中一种普通的技术，因为它们老要这样传递 list-of-hash 样的数据结构。Ruby 的解构语法相当精简，但是也足够达到这个简单的目的了。</p>
<p>用 clojure 也是差不多类似的：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">-&gt;&gt;</span></span> <span class="list">(<span class="keyword">articles</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword">group-by</span> <span class="attribute">:type</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">map</span></span> <span class="list">(<span class="keyword"><span class="built_in">fn</span></span> <span class="collection">[<span class="collection">[k v]</span>]</span> <span class="collection">[k <span class="list">(<span class="keyword"><span class="built_in">count</span></span> v)</span>]</span>)</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">into</span></span> <span class="collection">&#123;&#125;</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<h4 id="获取每个_tag_对应的文章数">获取每个 tag 对应的文章数</h4><p><img src="\img\pipeline-example-3.png" alt="example-3"></p>
<p>下一个 pipeline 我们需要统计每个 tag 对应的文章数，和单词数。要完成这个目标需要重新组织数据结构。顶层的项是 article，每个 article 可能包含 很多的 tag。我们需要把数据结构解开，让 tag 到顶层。一种想法是，这么做实际是在倒置一种多对多关系，因此 tag 才应该是聚合的元素。</p>
<p>重新组织 pipeline 开始的 collection 的层级解构会让事情变得复杂，但是仍然还是在该范式的掌控之内的。要这么做得把步骤细分一下，把一个完整的转换分成一份一份再串起来会更加易懂些。这也正是 collection pipeline 的思想所在。</p>
<p>第一步是关注 tag，解开数据结构我们才能为每个 tag 得到一条记录。这和你在关系型数据库中通过一张关系表展现一个多对多的关系十分相似。要这么做我将创建一个 lambda 表达式，以 article 为参数，产出一个 pair（包含 tag 和 article），然后将这个 lambda 作用于所有的 articles。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .map &#123;|a| a.tags.map&#123;|tag| [tag, a]&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>这会产生如下的数据结构：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[</span><br><span class="line">    <span class="collection">[ <span class="collection">[<span class="attribute">:nosql</span>, Article<span class="list">(<span class="keyword">NoDBA</span>)</span>]</span></span><br><span class="line">      <span class="collection">[<span class="attribute">:people</span>, Article<span class="list">(<span class="keyword">NoDBA</span>)</span>]</span></span><br><span class="line">      <span class="collection">[<span class="attribute">:orm</span>, Article<span class="list">(<span class="keyword">NoDBA</span>)</span>]</span></span><br><span class="line">    ]</span></span><br><span class="line">    <span class="collection">[ <span class="collection">[<span class="attribute">:nosql</span>, Article<span class="list">(<span class="keyword">Infodeck</span>)</span>]</span></span><br><span class="line">      <span class="collection">[<span class="attribute">:writing</span>, Article<span class="list">(<span class="keyword">Infodeck</span>)</span>]</span></span><br><span class="line">    ]</span></span><br><span class="line">    # more rows of articles</span><br><span class="line">]</span></span><br></pre></td></tr></table></figure>
<p>这个 map 的结果是一个 pair 的列表的列表。为每个 article 产生了一个嵌套列表。那个嵌套列表太碍事了，所以用一个 flatten 操作，将它平铺开来。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .map &#123;|a| a.tags.map&#123;|tag| [tag, a]&#125;&#125;</span><br><span class="line">    .flatten <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>生成</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[</span><br><span class="line">    <span class="collection">[<span class="attribute">:nosql</span>, Article<span class="list">(<span class="keyword">NoDBA</span>)</span>]</span></span><br><span class="line">    <span class="collection">[<span class="attribute">:people</span>, Article<span class="list">(<span class="keyword">NoDBA</span>)</span>]</span></span><br><span class="line">    <span class="collection">[<span class="attribute">:orm</span>, Article<span class="list">(<span class="keyword">NoDBA</span>)</span>]</span></span><br><span class="line">    <span class="collection">[<span class="attribute">:nosql</span>, Article<span class="list">(<span class="keyword">Infodeck</span>)</span>]</span></span><br><span class="line">    <span class="collection">[<span class="attribute">:writing</span>, Article<span class="list">(<span class="keyword">Infodeck</span>)</span>]</span></span><br><span class="line">    # more rows of articles</span><br><span class="line">]</span></span><br></pre></td></tr></table></figure>
<p>这种对没用的嵌套做平铺操作非常常见，因此大部分语言都内置了这样一种 flat-map 操作来一步完成。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .flat_map &#123;|a| a.tags.map&#123;|tag| [tag, a]&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>现在有了这样一个关于 pair 的 list，后面的操作就简单了，根据 tag 分组即可。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .flat_map &#123;|a| a.tags.map&#123;|tag| [tag, a]&#125;&#125;</span><br><span class="line">    .group_by &#123;|pair| pair.first&#125;</span><br></pre></td></tr></table></figure>
<p>生成</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;</span><br><span class="line">    <span class="attribute">:people:</span></span><br><span class="line">      <span class="collection">[  <span class="collection">[<span class="attribute">:people</span>, Article<span class="list">(<span class="keyword">NoDBA</span>)</span>]</span> ]</span></span><br><span class="line">    <span class="attribute">:orm:</span></span><br><span class="line">      <span class="collection">[  <span class="collection">[<span class="attribute">:orm</span>, Article<span class="list">(<span class="keyword">NoDBA</span>)</span>]</span></span><br><span class="line">         <span class="collection">[<span class="attribute">:orm</span>, Article<span class="list">(<span class="keyword">NoDBA</span>)</span>]</span></span><br><span class="line">      ]</span></span><br><span class="line">    <span class="attribute">:writing:</span></span><br><span class="line">      <span class="collection">[  <span class="collection">[<span class="attribute">:writing</span>, Article<span class="list">(<span class="keyword">Infodeck</span>)</span>]</span>  ]</span></span><br><span class="line">    # more records</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>又有嵌套层了，因为每个关联关系都是一个 key/article pair 的 list，而不是article 的 list。这个可以通过将 pair 映射成 article 来除去。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">some_article</span><br><span class="line">    .flat_map &#123;|a| a.tags.map[|tag| [tag, a]&#125;</span><br><span class="line">    .group_by &#123;|pair| pair.first&#125;</span><br><span class="line">    .map &#123; |k, pairs| [k, pairs.map&#123;|p| p.last&#125;]&#125;</span><br></pre></td></tr></table></figure>
<p>生成</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;</span><br><span class="line">    <span class="attribute">:people:</span>    <span class="collection">[ Article<span class="list">(<span class="keyword">NoDBA</span>)</span> ]</span></span><br><span class="line">    <span class="attribute">:orm:</span>       <span class="collection">[ Article<span class="list">(<span class="keyword">NoDBA</span>)</span>, Article<span class="list">(<span class="keyword">OrmHate</span>)</span> ]</span></span><br><span class="line">    <span class="attribute">:writing:</span>   <span class="collection">[ Article<span class="list">(<span class="keyword">Infodeck</span>)</span> ]</span></span><br><span class="line">    # more records</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>现在做到了把数据结构转换好了，反转了多对多的关系。要得到想要的结果只需要一个简单的 map 来提取所需要的数据即可。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .flat_map &#123;|a| a.tags.map[|tag| [tag, a]&#125;</span><br><span class="line">    .group_by &#123;|pair| pair.first&#125;</span><br><span class="line">    .map &#123;|k, pairs| [k, pairs.map&#123;|p| p.last&#125;]&#125;</span><br><span class="line">    .map &#123;|k, v| [k, &#123;<span class="symbol">articles:</span> v.size, <span class="symbol">words:</span> v.map(&amp;<span class="symbol">:words</span>).reduce(<span class="symbol">:+</span>)&#125;]&#125;</span><br><span class="line">    .to_h</span><br></pre></td></tr></table></figure>
<p>生成一个 hashes 的 hash：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">:nosql:</span></span><br><span class="line"><span class="code">    :articles: 4</span></span><br><span class="line"><span class="code">    :words: 3906</span></span><br><span class="line"><span class="attribute">:people:</span></span><br><span class="line"><span class="code">    :articles: 1</span></span><br><span class="line"><span class="code">    :words: 561</span></span><br><span class="line"><span class="attribute">:orm:</span></span><br><span class="line"><span class="code">    :articles: 2</span></span><br><span class="line"><span class="code">    :words: 2279</span></span><br><span class="line"><span class="attribute">:writing:</span></span><br><span class="line"><span class="code">    :articles: 1</span></span><br><span class="line"><span class="code">    :words: 1145</span></span><br><span class="line"><span class="attribute">:ruby:</span></span><br><span class="line"><span class="code">    :articles: 1</span></span><br><span class="line"><span class="code">    :words: 1313</span></span><br><span class="line"><span class="attribute">:ddd:</span></span><br><span class="line"><span class="code">    :articles: 1</span></span><br><span class="line"><span class="code">    :words: 482</span></span><br></pre></td></tr></table></figure>
<p>用 Clojure 做也是差不多的：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">-&gt;&gt;</span></span> <span class="list">(<span class="keyword">articles</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">mapcat</span></span> #<span class="list">(<span class="keyword"><span class="built_in">map</span></span> <span class="list">(<span class="keyword"><span class="built_in">fn</span></span> <span class="collection">[tag]</span> <span class="collection">[tag %]</span> <span class="list">(<span class="attribute">:tags</span> %)</span>)</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword">group-by</span> first)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">map</span></span> <span class="list">(<span class="keyword"><span class="built_in">fn</span></span> <span class="collection">[<span class="collection">[k v]</span>]</span> <span class="collection">[k <span class="list">(<span class="keyword"><span class="built_in">map</span></span> last v)</span>]</span>)</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">map</span></span> <span class="list">(<span class="keyword"><span class="built_in">fn</span></span> <span class="collection">[<span class="collection">[k v]</span>]</span> <span class="collection">[k <span class="collection">&#123;<span class="attribute">:articles</span> <span class="list">(<span class="keyword"><span class="built_in">count</span></span> v)</span>, <span class="attribute">:words</span> <span class="list">(<span class="keyword"><span class="built_in">reduce</span></span> + map <span class="attribute">:words</span> v)</span>)&#125;</span>&#125;</span>)</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">into</span></span> <span class="collection">&#123;&#125;</span>)</span></span></span></span><br></pre></td></tr></table></figure>
<p><em>Clojure’s flat-map operation is called mapcat.</em></p>
<p>建立起这样一个复杂的 pipeline 相当不容易。我觉得最简单的方法是每一次只专心做一步，仔细检查输出的 collection 是否正确，然后才能保证后面可以正确继续下去。要看输出对不对可能需要输出的格式有良好缩进易于阅读。或者你也可以先写测试，用一些简单的断言来判断数据是否正确，再继续追加 pipeline 的同时演进你的测试代码。</p>
<p>建立 pipeline 的过程是一步一步的，但是直接看最后的代码却难以理解。因为前面一大部分是在重新组织数据结构。因此我把这部分抽离出来到一个函数里了。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">defn</span></span> index-by <span class="collection">[f, seq]</span></span><br><span class="line">    <span class="list">(<span class="keyword"><span class="built_in">-&gt;&gt;</span></span> seq</span><br><span class="line">         <span class="list">(<span class="keyword"><span class="built_in">mapcat</span></span> #<span class="list">(<span class="keyword"><span class="built_in">map</span></span> <span class="list">(<span class="keyword"><span class="built_in">fn</span></span> <span class="collection">[key]</span> <span class="collection">[key %]</span>)</span> <span class="list">(<span class="keyword">f</span> %)</span>)</span>)</span></span><br><span class="line">         <span class="list">(<span class="keyword">group-by</span> first)</span></span><br><span class="line">         <span class="list">(<span class="keyword"><span class="built_in">map</span></span> <span class="list">(<span class="keyword"><span class="built_in">fn</span></span> <span class="collection">[<span class="collection">[k v]</span>]</span> <span class="collection">[k <span class="list">(<span class="keyword"><span class="built_in">map</span></span> last v)</span>]</span>)</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">defn</span></span> total-words <span class="collection">[articles]</span> </span><br><span class="line">    <span class="list">(<span class="keyword"><span class="built_in">reduce</span></span> + <span class="list">(<span class="keyword"><span class="built_in">map</span></span> <span class="attribute">:words</span> articles)</span>)</span>)</span></span><br><span class="line">  </span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">-&gt;&gt;</span></span> <span class="list">(<span class="keyword">articles</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword">index-by</span> <span class="attribute">:tags</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">map</span></span> <span class="list">(<span class="keyword"><span class="built_in">fn</span></span> <span class="collection">[<span class="collection">[k v]</span>]</span> <span class="collection">&#123;k <span class="collection">&#123;<span class="attribute">:articles</span> <span class="list">(<span class="keyword"><span class="built_in">count</span></span> v)</span>, <span class="attribute">:words</span> <span class="list">(<span class="keyword">total-words</span> v)</span>&#125;</span>&#125;</span>)</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">into</span></span> <span class="collection">&#123;&#125;</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>同时我也可以把计单词数的代码抽象出来。抽象出因子会增加行数，但是我觉得这让代码更易理解，是值得的。简短强大的代码是不错，但是简短只有建立于清晰之上时才有价值。</p>
<p>在面向对象语言中，要这么做需要添加一个函数到 collection class 中，因为在 pipeline 中，你只能使用 collection 内建的函数。在 ruby 里，可以这样写：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> </span>invert_index_by &amp;proc</span><br><span class="line">    flat_map &#123;|e| proc.call(e).map &#123;|key| [key, e]&#125;&#125;</span><br><span class="line">      .group_by &#123;|pair| pair.first&#125;</span><br><span class="line">      .map &#123;|k,pairs| [k, pairs.map &#123;|p| p.last&#125;]&#125;         </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这里我给它换了个名字，因为 index_by 在本地函数的语境内已经有意义了，但是对于 collection 类里的一个泛型方法来说，其实也无所谓。需要在 collection class 里添加方法是 OO 语言的负作用。有些平台根本不允许你修改库里的类，使得这种构建完全不可行。有些则允许你像这样通过 monkey patching 来修改这些类，但是这会在全局范围内造成类库 API 的变动，所以你要格外小心。最好的选择是像 C# 里的扩展机制，或者是 ruby 里的只在一个小的命名空间里的上下文中起效的细微改变。但是相比定义一个函数，使用 monkey-patch 还是有一对繁文缛节要遵守。</p>
<p>一旦定义好方法了，我们就可以重构这个 pipeline，让它像 clojure 那样。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">total_words = -&gt; (a) &#123;a.map(&amp;<span class="symbol">:words</span>).reduce(<span class="symbol">:+</span>)&#125;</span><br><span class="line">some_articles</span><br><span class="line">    .invert_index_by &#123;|a| a.tags&#125;</span><br><span class="line">    .map &#123;|k,v| [k, &#123;<span class="symbol">articles:</span> v.size, <span class="symbol">words:</span> total_words.call(v)&#125;]&#125;</span><br><span class="line">    .to_h</span><br></pre></td></tr></table></figure>
<p>这里我把统计词数的代码也抽象出来了，不过在 ruby 里这样不是很有效率，因为我不得不显示的调用我创建的函数。虽然不多，但是还是增加了<br>一点阅读难度。我可以把他定义成一个类方法，这样就省去了调用的语句。不过我会再走远些，添加一个类来包含这个求和函数。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleSummary</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> </span>initialize articles</span><br><span class="line">    <span class="variable">@articles</span> = articles</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> </span>size</span><br><span class="line">    <span class="variable">@articles</span>.size</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> </span>total_words</span><br><span class="line">    <span class="variable">@articles</span>.map&#123;|a| a.words&#125;.reduce(<span class="symbol">:+</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>使用方式如下：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .invert_index_by &#123;|a| a.tags&#125;</span><br><span class="line">    .map &#123;|k,v| [k, <span class="constant">ArticleSummary</span>.new(v)]&#125;</span><br><span class="line">    .map &#123;|k,a| [k, &#123;<span class="symbol">articles:</span> a.size, <span class="symbol">words:</span> a.total_words&#125;]&#125;</span><br><span class="line">    .to_h</span><br></pre></td></tr></table></figure>
<p>可能很多人觉得为了抽象出几个函数就引入一个新的类有点太重了。我自己写写本地代码时是没那么在意啦。但是在这例子中我是不很愿意的，因为真的只有一个统计单词的函数值得抽离出来。</p>
<h2 id="其他方案">其他方案</h2><p>Collection pipeline 范式不是唯一的手段，有一个替代方案是大多数人在一般情况下都在使用的：循环。</p>
<h4 id="使用循环">使用循环</h4><p>以获取 top 3 NoSQl articles 为例：</p>
<p><img src="\img\pipeline-loop-1.png" alt="pipeline-loop-1"></p>
<p>collection pipline 的版本更短一些，并且在我看来更加基础易懂，因为我比较熟嘛。换句话说，循环的版本也不差。</p>
<p>下面是统计单词数的例子：</p>
<p><img src="\img\pipeline-loop-2.png" alt="pipeline-loop-2"></p>
<p>分组的例子：</p>
<p><img src="\img\pipeline-loop-3.png" alt="pipeline-loop-3"></p>
<p>每个 tag 的文章数：</p>
<p><img src="\img\pipeline-loop-4.png" alt="pipeline-loop-4"></p>
<p>这下 collection pipeline 要简短多了。不过这种比较也不是十分公平啦。</p>
<h4 id="使用推导式_(Comprehensions)">使用推导式 (Comprehensions)</h4><p>有些语言提供了推导，通常称作列表推导 (list comprehensions)，就像一个简化的 collection pipelines。假设需要获取所有长度超过1000的文章的标题，我会使用 coffeescript 来演示列表推导，用原生 Javascript 演示 collection pipelines。</p>
<p><img src="\img\pipeline-comprehensions-1.png" alt="pipeline-comprehensions-1"></p>
<p>不同语言之间列表推导的能力各不相同，不过你可以把它当作是一种把操作序列表达成一句语句的方法。这种想法阐明了什么时候该使用它。它只能被用于一些特定的 pipeline collections 的组合，因此灵活性并不强。意味着它只是为了一些通用情形而定义的，因此在很多情形中它们只是一个选项罢了。</p>
<p>comprehensions 也可以被放到 pipelines 中，作为一个 operation。因此，要获取所有超过千字的文章的单词数可以这样写：</p>
<p><img src="\img\pipeline-comprehensions-2.png" alt="pipeline-comprehensions-2"></p>
<p>那么问题是，什么时候用 Comprehensions 更好呢？双方粉丝各有理解。</p>
<h2 id="嵌套操作符表达式">嵌套操作符表达式</h2><p>好处之一是你可以用集合操作来操作 collections。假设要使用表达式来找出那些 unoccupied red or blue rooms at the front of the hotel.</p>
<p><em>ruby</em></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">front</span> &amp; <span class="list">(<span class="keyword">red</span> | blue)</span>)</span> - occupied</span><br></pre></td></tr></table></figure>
<p><em>clojure</em></p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">difference</span></span></span><br><span class="line">    <span class="list">(<span class="keyword"><span class="built_in">intersection</span></span></span><br><span class="line">        <span class="list">(<span class="keyword"><span class="built_in">union</span></span> reds blues)</span></span><br><span class="line">        fronts)</span></span><br><span class="line">    occ)</span></span><br></pre></td></tr></table></figure>
<p><em>Clojure defines set operations on its set datatype, so all the symbols here are sets.</em></p>
<p>也可以用 collection pipelines 表达式的形式</p>
<p><em>ruby</em></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">red</span><br><span class="line">  .union(blue)</span><br><span class="line">  .intersect(front)</span><br><span class="line">  .diff(occupied)</span><br></pre></td></tr></table></figure>
<p><em>I monkey-patched Array to add the set operations as regular methods</em></p>
<p><em>clojure</em></p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">-&gt;&gt;</span></span> reds</span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">union</span></span> blues)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">intersection</span></span> fronts)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">remove</span></span> occ)</span>)</span></span><br></pre></td></tr></table></figure>
<p><em>I need clojure’s ‘remove’ method here in order to get the arguments in the right order for threading.</em></p>
<p>我更喜欢嵌套操作符表达式的形式，因为可以使用前缀操作符。当足够表达式复杂时也会和 pipes 一样一团乱。</p>
<p>也就是说，在 pipeline 中间用集合操作经常是有用的。假设颜色和位置时房间记录的属性，但是有客房间的列表是另一个 collection。</p>
<p><em>ruby</em></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rooms</span><br><span class="line">  .select&#123;|r| [<span class="symbol">:red</span>, <span class="symbol">:blue</span>].<span class="keyword">include</span>? r.color&#125;</span><br><span class="line">  .select&#123;|r| <span class="symbol">:front</span> == r.location&#125;</span><br><span class="line">  .diff(occupied)</span><br></pre></td></tr></table></figure>
<p><em>clojure</em></p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">-&gt;&gt;</span></span> <span class="list">(<span class="keyword">rooms</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">filter</span></span> #<span class="list">( #<span class="collection">&#123;<span class="attribute">:blue</span> <span class="attribute">:red</span>&#125;</span> <span class="list">(<span class="attribute">:color</span> %)</span>)</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">filter</span></span> #<span class="list">( #<span class="collection">&#123;<span class="attribute">:front</span>&#125;</span> <span class="list">(<span class="attribute">:location</span> %)</span>)</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">remove</span></span> <span class="list">(<span class="keyword">set</span> <span class="list">(<span class="keyword">occupied</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p><em>Here I’m showing (set (occupied)) to show how we’d use a set wrapped over a collection as a predicate for the set membership in clojure.</em></p>
<p>尽管前缀操作符对于嵌套操作符表达式来说是不错，但是和 pipelines 不太合得来。</p>
<p><em>ruby</em></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">((rooms</span><br><span class="line">  .select&#123;|r| [<span class="symbol">:red</span>, <span class="symbol">:blue</span>].<span class="keyword">include</span>? r.color&#125;</span><br><span class="line">  .select&#123;|r| <span class="symbol">:front</span> == r.location&#125;</span><br><span class="line">  ) - occupied)</span><br><span class="line">  .map(&amp;<span class="symbol">:num</span>)</span><br><span class="line">  .sort</span><br></pre></td></tr></table></figure>
<p>另一个有关集合 (set) 操作符的想法是 collections 通常是有序的并且允许重复的列表。你必须非常清楚你使用的库里集合操作的真正含义。Clojure 会强迫你先把你的列表转换为集合 (set)。Ruby 会接受你传入的任意一个数组来进行集合操作，并自动保留顺序移除重复项。</p>
<h2 id="Laziness">Laziness</h2><p>Laziness 的概念源自函数式编程世界。动机可能是源自下面这样的代码：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">large_list</span><br><span class="line">    .map&#123;|e| slow_complex_method (e)&#125;</span><br><span class="line">    .take(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>这样的代码会花大部分时间在对每个元素计算 slow_complex_method 上，然后将除了 top 5 以外的结果全部丢弃。Laziness 允许底层平台发现你只需要5个结果，然后只对必要的项进行 slow_complex_method 运算。</p>
<p>这个的确是深入到了对运行时的使用，比如 slow_complex_method 的结果被 pipe 到 UI 的滚动菜单里的情形。一个 lazy pipeline 会仅仅在最终结果上调用 pipeline。</p>
<p>让 collection pipeline 变得 lazy，在建立时需要在构思中就带着 laziness。有些语言，通常是函数式语言比如 Clojure 和 Haskell，从开头就开始了。其他情形中，laziness 则可以被建立在特定一组 collection 类中 － Java 和 Ruby 有一些 lazy collection 的实现。</p>
<p>有些 pipeline 操作无法和 laziness 结合，必须运算整个列表。排序就是一例，不遍历整个列表是无法获取最大值的，尽管最大值只有一个。正经支持 laziness 的平台一般都会有有文档注明哪些操作时无法维持 laziness 的。</p>
<h2 id="并行_Parallelism">并行 Parallelism</h2><p>很多 pipeline 操作都天生可以并行调用。比如使用 map，对一个元素的计算结果不会受其他元素影响。所以假如程序运行在多核上，我可以通过多线程充分利用分布式 map 运算的优势。</p>
<p>很多平台都提供这种并行的分布式运算的能力。如果你在用一个复杂函数处理一个超大的集合，利用多核可能会有显著的性能提升。</p>
<p>然而并行化不一定总能提升性能。有可能你搭建并行环境的时间已经超过你从并行运算中能获得的时间收益里。因此，大多数平台都会显式的提供备选方案来让你选择是否使用并行化，比如 Clojure 的 pmap 就是 map 的并行版本。为了性能优化考虑，你应该用性能测试来确定是否真有性能方面的提升。</p>
<h2 id="不可变性">不可变性</h2><p>Collection-pipelines 天生就把自己交付给力了不可变的数据结构。当构建一个 pipeline 时，很自然的就会为每一个操作新建一个 collection 来放输出。简单的这么做涉及到很多的拷贝，一旦数据量巨大，很可能出问题。不过大部分时候都无需考虑这个问题。通常情况下，都是用几个指针而非真正的数据块。</p>
<p>一旦真成问题了，你可以使用那些专门来应对这种传递的数据结构来保持不变性。函数式语言趋向于使用可以用这种方式高效操纵的数据结构。</p>
<p>有必要的话，你也可以通过使用那些更新 collection 的操作来牺牲可变性。在非函数式编程的类库中同通常也会提供 collection pipeline operator 的破坏版本。我建议你仅在性能调节试验中使用它们。用不可变的操作吧，除非你已经明确遇到 pipeline 中的性能瓶颈了。</p>
<h2 id="调试">调试</h2><p>对于调试一个 collection pipeline，我有一堆问题。比如下面这个 ruby 程序：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> </span>get_readers_of_books1(readers, books, date)</span><br><span class="line">  data = <span class="variable">@data_service</span>.get_books_read_on(date)</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">    .select&#123;|k,v| readers.<span class="keyword">include</span>?(k)&#125;</span><br><span class="line">    .select&#123;|k,v| !(books &amp; v).empty?&#125;</span><br><span class="line">    .keys</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>现代IDE当然能帮上许多忙，不过还是假设我们在编辑器中且没有调试器。</p>
<p>我可能想要在 pipe 中间某一步获取些中间值。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> </span>get_readers_of_books2(readers, books, date)</span><br><span class="line">  data = <span class="variable">@data_service</span>.get_books_read_on(date)</span><br><span class="line">  temp = data</span><br><span class="line">    .select&#123;|k,v| readers.<span class="keyword">include</span>?(k)&#125;</span><br><span class="line">    .select&#123;|k,v| !(books &amp; v).empty?&#125;</span><br><span class="line">  pp temp</span><br><span class="line">  <span class="keyword">return</span> temp</span><br><span class="line">    .keys</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>还有一个比较 tricky 的做法是把输出语句也通过 map 弄到 pipeline 中。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> </span>get_readers_of_books(readers, books, date)</span><br><span class="line">  data = <span class="variable">@data_service</span>.get_books_read_on(date)</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">    .select&#123;|k,v| readers.<span class="keyword">include</span>?(k)&#125;</span><br><span class="line">    .select&#123;|k,v| !(books &amp; v).empty?&#125;</span><br><span class="line">    .map &#123;|e| pp e; e&#125;.to_h</span><br><span class="line">    .keys</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><em>In this case I need to convert back to a hash after the map operation</em></p>
<p>尽管可以帮助你知道代码在做些什么，但是可别忘了删了。</p>
<p>用一个好的调试器，你通常可以看到各个表达式的值。你只需要打好断点就可以看 pipe 的各个部分在发生些啥了。</p>
<h2 id="何时使用">何时使用</h2><p>作为一个范式，和其他范式一样有什么时候该用什么时候不用的问题。</p>
<p>第一个不该用的情形是，语言本身不支持。刚用 Java 时，老是试图在给对象加上一些操作来模拟这个范式，但最后代码往往一团糟也没有性能。因此我放弃了转而使用循环。尽管后来有一些函数式风格的库出现了，但是我还是觉得没有良好的 lambda 支持，运用这个范式还是会遇到许多麻烦。</p>
<p>另一个争论是，存在推导 (comprehension) 的情形，有推导可以更轻易的处理一些简单的表达式，不过处理复杂的你还是需要 pipeline 的。个人觉得 pipeline 和推导一样简单易懂，当然，这问题应该是团队定编程风格的时候考虑的。</p>
<p>即使语言支持，你也应当注意 pipeline 的大小，不要太大了，适当拆分并将一部分函数抽象出来。</p>
<p>Collection pipeline 是一种优秀的范式，一种所有程序员都了解的东西，在特别是 ruby 和 clojure 这样良好支持的语言中。也可以在很多情形下替代冗长的循环，增强可读性，易于改善。</p>
<h2 id="操作目录">操作目录</h2><p>下面是一些在 collection pipeline 中常见操作的目录。每种语言都选择了几个可用的操作，并且各自命名。但是我尝试根据功能梳理了一下。</p>
<ul>
<li><strong>collect</strong><br><em>同 map，源自 Smalltalk。Java8 则把 collect 用于完全不同的功能：一个将元素从 stream 里弄到 collections 里的终端。</em></li>
</ul>
<p>see map</p>
<ul>
<li><strong>distinct</strong></li>
</ul>
<p><img src="\img\pipeline-distinct.png" alt="pipeline-distinct"><br><em>去除重复项</em></p>
<ul>
<li><strong>flat-map</strong></li>
</ul>
<p><img src="\img\pipeline-flatmap.png" alt="pipeline-flatmap"><br><em>对 collection 应用 map，并展开一层。</em></p>
<ul>
<li><strong>group-by</strong></li>
</ul>
<p><img src="\img\pipeline-groupby.png" alt="pipeline-groupby"><br><em>对每个元素运行，并按照结果分组。</em></p>
<ul>
<li><strong>map</strong></li>
</ul>
<p><img src="\img\pipeline-map.png" alt="pipeline-map"><br><em>用给定的函数作用于输入的每一元素，并将结果放到输出中。</em></p>
<ul>
<li><strong>reject</strong><br><em>和 filter 相反，返回不符合判定的元素</em></li>
</ul>
<p>see filter</p>
<ul>
<li><strong>sort</strong></li>
</ul>
<p><img src="\img\pipeline-sort.png" alt="pipeline-sort"><br><em>输出是将输入排序后的结果，用指定的分隔符分隔。</em></p>
<ul>
<li><strong>concat</strong></li>
</ul>
<p><img src="\img\pipeline-concat.png" alt="pipeline-concat"><br><em>将多个 collections 串联成一个</em></p>
<ul>
<li><strong>drop</strong></li>
</ul>
<p><em>slice 的一种形式，返回除了前 n 个元素外的所有元素。</em></p>
<p>see slice</p>
<ul>
<li><strong>flatten</strong></li>
</ul>
<p><img src="\img\pipeline-flatten.png" alt="pipeline-flatten"><br><em>把 collection 里的嵌套去掉。</em></p>
<ul>
<li><strong>inject</strong></li>
</ul>
<p><em>reduce 的另一种命名，来自 Smalltalk 的 inject:into: 选择器。</em></p>
<ul>
<li><strong>mapcat</strong></li>
</ul>
<p><em>flat-map 的另一种命名</em></p>
<p>see flat-map</p>
<ul>
<li><strong>select</strong></li>
</ul>
<p><em>filter 的 另一种命名</em></p>
<ul>
<li><strong>take</strong></li>
</ul>
<p><em>slice 的一种形式，返回前 n 个元素</em></p>
<p>see slice</p>
<ul>
<li><strong>difference</strong></li>
</ul>
<p><img src="\img\pipeline-difference.png" alt="pipeline-difference"></p>
<ul>
<li><strong>filter</strong></li>
</ul>
<p><img src="\img\pipeline-filter.png" alt="pipeline-filter"><br><em>对每个元素运行一个布尔函数，把通过的放入输出中</em></p>
<ul>
<li><strong>fold</strong></li>
</ul>
<p><em>有些时候是 reduce 的另一种命名。常见为 foldl (fold-left) 和 flodr (fold-right)</em></p>
<ul>
<li><strong>intersection</strong></li>
</ul>
<p><img src="\img\pipeline-intersection.png" alt="pipeline-intersection"><br><em>保留同时出现在提供的 collections 里的元素</em></p>
<ul>
<li><strong>reduce</strong></li>
</ul>
<p><img src="\img\pipeline-reduce.png" alt="pipeline-reduce"><br><em>使用提供的函数将输入合并，通常情况下返回单个值</em></p>
<ul>
<li><strong>slice</strong></li>
</ul>
<p><img src="\img\pipeline-slice.png" alt="pipeline-slice"><br><em>给定列表的起始位置和结束位置，返回子序列</em></p>
<ul>
<li><strong>union</strong></li>
</ul>
<p><img src="\img\pipeline-union.png" alt="pipeline-union"><br><em>返回所有提供的 collections 的元素的去重后的列表</em></p>
<h2 id="Ref-">Ref.</h2><p><a href="http://martinfowler.com/articles/collection-pipeline/" target="_blank" rel="external">Collection Pipeline</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这篇文章讲管道编程，深入浅出，推荐阅读。翻译过程中，在可能造成误解的名词上都保留了英文。</p>
</blockquote>
<p><strong>原文作者：Martin Fowler</strong></p>
<p>Collection pipelines 是一种编程范式，通过把一个操作的输出当作下个操作的输入来把计算组织成序列型的操作。（常用的操作是 filter，map，和 reduce。）这种范式在函数式编程中很普通，也存在于支持 lambda 的面向对象语言中。这篇文章将用一些例子来描述这种范式时如何形成 pipeline 的，同时也是给不熟悉这种范式的同学的一个介绍，也希望能帮助人们理解当中的核心概念，在不同语言间切换时能够触类旁通。</p>
<p>Collection pipeline 是最常见最舒服的范式之一了。比如 unix 命令行中，更好的面向对象语言中，还有最近引人瞩目的函数是语言中都有出现。不同的环境下或多或少会有些不同，同一个操作有不同的命名等，但是一旦你熟悉了这个范式，那么你一定会欲罢不能的。</p>]]>
    
    </summary>
    
      <category term="函数式编程" scheme="http://evthoriz.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[控制反转和依赖注入［译］]]></title>
    <link href="http://evthoriz.github.io/2015/07/09/IOC-and-DI/"/>
    <id>http://evthoriz.github.io/2015/07/09/IOC-and-DI/</id>
    <published>2015-07-08T16:00:00.000Z</published>
    <updated>2015-07-10T16:53:30.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这是一篇讲依赖注入概念的入门文章，非常浅显，翻译是为了看看语文是否退化 :)<br>翻完之后发现原来已经有人翻过了……</p>
</blockquote>
<p><strong>原文作者</strong>：<em>Martin Fowler</em></p>
<p>在 Java 社区中有不少的轻量级容器，可以将来自不同项目的组件结合起来构建一个完整的应用。这些容器的根本是基于一种通用的模式，一个被通俗的称为控制反转（IOC）的基本概念。我会在这篇文章中用依赖注入（DI）这个更专门的名词来深层阐述这个模式是如何运作的，并且会和 Service Locator 这种方案做出对比。相比在他们两个之间做选择，将配置与使用分离这个准则更为重要。</p>
<a id="more"></a>
<hr>
<p>在 Java 企业开发的领域中有一件事情比较好笑，有非常多的人乐此不疲的去创造主流的 J2EE 技术的替代品，大部分出现在开源项目中。而这其实是对主流 J2EE 世界里的技术太重太复杂的一种反馈，但是其中也生出了许多创造性的想法。有一个常见的要处理的事情是如何将不同的元素联系起来：如何将这个团队开发的 web controller 和那个团队的 database interface 组合在一起。有一部分的框架在这个问题上尝试许久，其中一些探索出了新的方法来将这些不同的组件在不同的层面上组合起来。这些即是我们称为轻量级容器的框架，例如 PicoContainer 和 Spring。</p>
<p>这些容器蕴含一些很有意思的设计准则，这些设计准则是超越了具体的容器和 Java 平台的。我会讲讲它们中的几个，例子用的是 Java 语言，但是道理对于所有面向对象的环境都是一样的。</p>
<h2 id="Components_and_Services">Components and Services</h2><p>将元素联系起来一下就让我想到了那些环绕在 Services 和 Components 周围的难懂的术语。关于那些定义，你很容易就能找到一堆冗长而有互相矛盾的文章。下面我讲讲我的理解。</p>
<p>Component 就是一些我开发应用时想要用的软件，这些软件怎么用完全不关它们的开发者的事了。当然我不会修改它们的源码。除非真有这个必要。</p>
<p>Service 从用的角度来说和 component 一样，都是我的应用需要用到的，但不像 component，被打包成了 jar 之类的放在我本地用，而是通过一些远程接口被远程调用的，不论同步异步。比如 web service，message service，RPC 之类。</p>
<p>这片文章我主要会用 service，但是很多逻辑也可以套用在 component 上。 实际上你经常会需要在你的本地 component framework 里去调用一个远程的 service。</p>
<h2 id="一个简单的例子">一个简单的例子</h2><p>为了理解起来更准确，我会用一个运行中的例子来讲解。这个例子非常简约但是希望你能因此更专注于思想而不会被真实的有庞杂代码的例子所迷惑。</p>
<p>在这个例子里我会写一个component，它将提供某位导演的电影列表。用单个方法即可实现。</p>
<p><em>class MovieLister</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Movie[] moviesDirectedBy(String arg) &#123;</span><br><span class="line">    List allMovies = finder.findAll();</span><br><span class="line">    <span class="keyword">for</span> (Iterator it = allMovies.iterator(); it.hasNext();) &#123;</span><br><span class="line">        Movie movie = (Movie) it.next();</span><br><span class="line">        <span class="keyword">if</span> (!movie.getDirector().equals(arg)) it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Movie[]) allMovies.toArray(<span class="keyword">new</span> Movie[allMovies.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的实现极度简单，通过一个 finder 对象返回所有的电影。然后遍历列表找出属于这个导演的电影。代码简单不再赘述，真正的关键点在于这个 finder 对象，或者说如何将列表对象连接在 finder 对象上。关注这个的原因是，我希望 moviesDirectedBy 这个方法完全不要依赖于这个列表具体是怎么存的。因此这个方法需要做的仅仅是引用这个 finder， 然后 finder 只需要知道对于 findAll 它该返回些什么就够了。要达到这个目的，我可以为 finder 定义一个 interface<br>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MovieFinder</span> </span>&#123;</span><br><span class="line">    <span class="function">List <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的，现在终于解耦了。但是还是需要有个 class 来提供电影的不是。在这个例子里，我把这部分代码放在 lister class 的构造函数里了。</p>
<p><em>class MovieLister</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MovieFinder finder;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MovieLister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    finder = <span class="keyword">new</span> ColonDelimitedMovieFinder(<span class="string">"movies1.txt"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个实现类的名字可以看出来电影列表将会从一个逗号分割的文件中读出来。具体的实现就不用多在意，反正它是这么个作用。</p>
<p>如果这个类只是我用用而已，那么这个 class 已经足够了。但是假如说我的朋友也超级想用我的这个方法想要拷贝我的代码过去怎么办呢？当然，如果它的电影文件也是按照逗号分割且命名为 moviews1.txt 的话，那就没问题。如果他们的电影文件名不一样，那也没关系，把名字放配置文件里就行。但是假如他们的电影放在一个完全不同的地方呢，比如数据库，XML文件，或者一个web service 上，那该怎么办？在这个例子里，我们需要定义一个不同的 class 去获取数据。不过我们不需要修改 moviesDirectedBy 方法，因为我们定义了 MovieFinder 接口。不过，还是需要一种途径去获取 finder 的正确实现的对象。</p>
<p><img src="\img\injection-1.gif" alt="Figure1"></p>
<p><em>Figure 1: The dependencies using a simple creation in the lister class</em></p>
<p>Figure1 展示了现在情形下的依赖关系，MovieLister class 同时依赖 MoviewFinder interface 和它的实现类。如果只依赖接口当然更好了，但是这样的话我们去哪里获取实例呢？</p>
<p>在我的书 P of EAA 中，我称这种做法为 Plugin 。finder 的实现类并不在程序编译的时候链接上，因为我无法预测我的朋友会怎么用它。我想要它能过应对任何一种实现，为此这个实现类需要在后面阶段再插进去，不经由我却仍能够找到实例。</p>
<p>把这种思想扩展到真实的系统中，我们可能会遇到一堆这样的 services 和 components。每一种情况我们都能把对 components 的使用抽象成对它们的接口的使用（如果这个 components 和定义的接口不符的话加个 Adapter 就可以了）。但是假如我们希望用不同的方式部署这个系统，我们需要使用 plugins 来处理和这些 services 的交互，这样我们在不同的部署中才能使用不同的实现。</p>
<p>所以核心的问题时我们该如何将这些 plugins 集成到一个应用中呢？这个就是一众轻量级容器面临的主要问题，且，通常来说它们的应对方法都是控制反转（IOC）。</p>
<h2 id="控制反转">控制反转</h2><p>当这些容器说自己实现了控制反转（Inversion of Control）而多有用时，我就奇了怪了。控制反转根本就是框架的标配嘛。说我的框架因为有了控制反转所以特别，就如同讲我的汽车因为有轮子所以很特别一样啊。</p>
<p>问题是，“它们在那个方面反转了？”。 当我最开始接触控制反转，它还是在用户接口上扮演的角色。早期的用户接口是被应用程序控制的。你会面对诸如 “Enter name”, “Enter address”;你的程序会驱动这些提示符并且给出不同的响应。如果是图形界面的话，UI 框架会包含一个循环，并且你的程序会为屏幕上这些不同的控件提供事件处理器（event handlers）。这个程序的主要控制被反转了，从你那被移交给了 UI 框架。</p>
<p>对于这些新的容器而言，反转说的是它们如何去找 plugin 实现。在我那个简单例子里，lister 通过直接实例化它来获取 finder。显然这让 finder 成不了一个 plugin。这些容器所用的途径是确保使用 plugin 的用户会遵循某些约定来将一个单独的模块注入到 lister 的实现中。</p>
<p>如此一来，我们需要一个专门的名次来命名这种模式。控制反转太宽泛了，并且让人感到疑惑。在与众多控制反转的拥护者的多次讨论中，我们最终决定将其命名为依赖注入（Dependency Injection）。</p>
<h2 id="依赖注入的形式">依赖注入的形式</h2><p>依赖注入的基本思想是将一个单独的对象或者说是 assembler，通过 finder 接口的合适的实现，装进 lister 里面的一个属性中。依赖关系见 Figure 2 里的连线。</p>
<p><img src="\img\injection-2.gif" alt="Figure2"><br><em>Figure 2: The dependencies for a Dependency Injector</em></p>
<p>主要存在三种形式的依赖注入。我称它们为，构造函数（Constructor）注入，setter 方法注入和接口（interface）注入。如果你读到过关于 IOC 讨论的种种，你可能会听到这样的分类，type 1 IoC (interface injection), type 2 IoC (setter injection) 和 type 3 IoC (constructor injection)。这些数字简直不能再难记，因此我还是选择用名字。</p>
<h3 id="PicoContainer_的构造函数注入">PicoContainer 的构造函数注入</h3><p>下面我将用一个叫做 PicoContainer 的轻量级容器来举例这种注入是实现的。这全然是因为我的几个同事对这个项目的热诚十足（对，我就是这么任人唯亲）。</p>
<p>PicoContainer 使用构造函数来决定如何将一个 finder 的实现注入到 lister 类中。为此这个 movie lister 类需要声明一个构造函数来将所有需的东西囊括进来。</p>
<p><em>class MovieLister</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MovieLister</span><span class="params">(MovieFinder finder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.finder = finder;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>finder 自身也会由 pico 的容器所管理，因此也需要通过容器将文本的文件名注入它里面。</p>
<p><em>class ColonMovieFinder</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ColonMovieFinder</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.filename = filename;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，需要告知 Pico 容器哪些实现类对应哪些接口，还有哪个字符串该被注入到 finder 里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MutablePicoContainer <span class="title">configureContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MutablePicoContainer pico = <span class="keyword">new</span> DefaultPicoContainer();</span><br><span class="line">    Parameter[] finderParams =  &#123;<span class="keyword">new</span> ConstantParameter(<span class="string">"movies1.txt"</span>)&#125;;</span><br><span class="line">    pico.registerComponentImplementation(MovieFinder.class, ColonMovieFinder.class, finderParams);</span><br><span class="line">    pico.registerComponentImplementation(MovieLister.class);</span><br><span class="line">    <span class="keyword">return</span> pico;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个配置代码是在其他类里面写的。在我们这个例子中，每个用这个 lister 的人都可能将这样的配置代码写在他们自己的类里面。当然把这样的配置信息单独放在配置文件里也挺常见的。你可以再写一个类去加载这个配置文件，让容器能够正确配置。尽管 PicoContainer 没有包含这样一个功能，但有一个非常相关的项目 NanoContainer 提供了一个 wrapper 来让你能够处理 XML 配置文件。NanoContainer 会解析 XML 然后正确的配置好它下面的 pico 容器。这个做法的哲学思想是将配置文件的格式和底层机制独立开来。</p>
<p>要使用这个容器你需要下面的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWithPico</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MutablePicoContainer pico = configureContainer();</span><br><span class="line">    MovieLister lister = (MovieLister) pico.getComponentInstance(MovieLister.class);</span><br><span class="line">    Movie[] movies = lister.moviesDirectedBy(<span class="string">"Sergio Leone"</span>);</span><br><span class="line">    assertEquals(<span class="string">"Once Upon a Time in the West"</span>, movies[<span class="number">0</span>].getTitle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管我用了构造函数注入的方法，PicoContainer 也是支持 setter 注入的。</p>
<h3 id="Spring_的_setter_注入">Spring 的 setter 注入</h3><p>Spring 框架是一个企业级 Java 开发的的全套框架。它的抽象层包含了事务，持久化，web应用开发还有JDBC。像 PicoContainer， 它支持构造函数注入和 setter 注入。但是它的开发者偏向使用后者，那用它来当例子再好不过了。</p>
<p>为了让 movie lister 能够接受注入，我要在服务里定义一个 setter 方法。</p>
<p><em>class MovieLister</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MovieFinder finder;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFinder</span><span class="params">(MovieFinder finder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.finder = finder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，为文件名定义个 setter 方法。</p>
<p><em>class ColonMovieFinder</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFilename</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.filename = filename;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三部是建立配置文件。Spring 支持通过 XML 文件和代码来进行配置，但是偏向于 XML 。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"MovieLister"</span> <span class="attribute">class</span>=<span class="value">"spring.MovieLister"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"finder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">ref</span> <span class="attribute">local</span>=<span class="value">"MovieFinder"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"MovieFinder"</span> <span class="attribute">class</span>=<span class="value">"spring.ColonMovieFinder"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"filename"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">value</span>&gt;</span>movies1.txt<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWithSpring</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"spring.xml"</span>);</span><br><span class="line">    MovieLister lister = (MovieLister) ctx.getBean(<span class="string">"MovieLister"</span>);</span><br><span class="line">    Movie[] movies = lister.moviesDirectedBy(<span class="string">"Sergio Leone"</span>);</span><br><span class="line">    assertEquals(<span class="string">"Once Upon a Time in the West"</span>, movies[<span class="number">0</span>].getTitle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口注入">接口注入</h3><p>第三种注入方式是通过接口。Avalon 是当下提供这种方式的框架。先用一个简单的例子来掩饰，后面详谈。</p>
<p>先要定义一个接口来给我们用来注入用。下面这个接口就是把一个movie finder 注入到一个对象中用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InjectFinder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">injectFinder</span><span class="params">(MovieFinder finder)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口可以由任意一个提供 MovieFinder 接口的人定义。它可以由任何想要使用 finder 的类所实现，比如 lister。</p>
<p><em>class MovieLister implements InjectFinder</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectFinder</span><span class="params">(MovieFinder finder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.finder = finder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用相似的方式将文件名注入到finder的实现中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InjectFinderFilename</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">injectFilename</span> <span class="params">(String filename)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>class ColonMovieFinder implements MovieFinder, InjectFinderFilename</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectFilename</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.filename = filename;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，和往常一样，需要些配置代码将实现给链接上。简单起见就这样写了。</p>
<p><em>class Tester</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Container container;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    container = <span class="keyword">new</span> Container();</span><br><span class="line">    registerComponents();</span><br><span class="line">    registerInjectors();</span><br><span class="line">    container.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个配置分两个阶段，通过查询 key 来注册components和其他例子非常相似。</p>
<p><em>class Tester</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerComponents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    container.registerComponent(<span class="string">"MovieLister"</span>, MovieLister.class);</span><br><span class="line">    container.registerComponent(<span class="string">"MovieFinder"</span>, ColonMovieFinder.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新的一步是注册这些注入器将会注入相关的 components。每一个注入接口需要代码去注入相关的对象。这边我通过在容器里注册注入器来实现。每一个注入器对象实现了注入器接口。</p>
<p><em>class Tester</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerInjectors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    container.registerInjector(InjectFinder.class, container.lookup(<span class="string">"MovieFinder"</span>));</span><br><span class="line">    container.registerInjector(InjectFinderFilename.class, <span class="keyword">new</span> FinderFilenameInjector());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Injector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容器使用声明的注入接口去找到依赖和注入器来注入正确的依赖。</p>
<h2 id="Using_a_Service_Locator">Using a Service Locator</h2><p>DI部分到此为止，后面太多，略。</p>
<h3 id="原文地址">原文地址</h3><p><a href="http://www.martinfowler.com/articles/injection.html" target="_blank" rel="external">Inversion of Control Containers and the Dependency Injection pattern</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这是一篇讲依赖注入概念的入门文章，非常浅显，翻译是为了看看语文是否退化 :)<br>翻完之后发现原来已经有人翻过了……</p>
</blockquote>
<p><strong>原文作者</strong>：<em>Martin Fowler</em></p>
<p>在 Java 社区中有不少的轻量级容器，可以将来自不同项目的组件结合起来构建一个完整的应用。这些容器的根本是基于一种通用的模式，一个被通俗的称为控制反转（IOC）的基本概念。我会在这篇文章中用依赖注入（DI）这个更专门的名词来深层阐述这个模式是如何运作的，并且会和 Service Locator 这种方案做出对比。相比在他们两个之间做选择，将配置与使用分离这个准则更为重要。</p>]]>
    
    </summary>
    
      <category term="框架" scheme="http://evthoriz.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gRPC 入门及源码分析]]></title>
    <link href="http://evthoriz.github.io/2015/07/07/gRPC-tutorial/"/>
    <id>http://evthoriz.github.io/2015/07/07/gRPC-tutorial/</id>
    <published>2015-07-06T16:00:00.000Z</published>
    <updated>2015-07-09T04:20:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="基于_protobuf_的_RPC_框架">基于 protobuf 的 RPC 框架</h2><p>在众多序列化器中，protobuf 的设计在速度、体积以及兼容性的考虑上折中的非常好。跨语言跨平台，简单易用，受众广泛。只是不像 thrift 有配套的 RPC 框架实现。gRPC 即是最近由 google 开源的一套基于 protobuf 的 RPC 框架，当然，它也支持 Json，Thrift，XML 等其他序列化方式。</p>
<h2 id="RPC_架构">RPC 架构</h2><p><strong>RPC</strong> 的实现思路大同小异，以动态代理为例，定义好接口，用一个代理假装实现了这个接口（真正的实现放在服务端），供客户端调用，代理内部将该方法调用封装成一个网络请求送到服务端。服务端根据参数找到对应的注册好的对象处理，返回给客户端。<br><a id="more"></a></p>
<p>gRPC 官网提供的概念图如下<br><img src="\img\grpc_concept.png" alt="gRPC_concept"><br>客户端调用 stub 对象，所谓 stub 对象就是具有声明好的方法的 fake object，让你可以调用方法而已，角色和上面讲到的代理对象一样。在 <strong>gRPC</strong> 里，<strong>stub</strong> 对象将请求用 <strong>protobuf</strong> 方式序列化成字节流，用于线上传输，到 <strong>server</strong> 端后调用真正的实现对象处理。</p>
<h2 id="gRPC_入门实例">gRPC 入门实例</h2><h3 id="Step1-_定义_proto_文件">Step1. 定义 proto 文件</h3><p>用 <strong>gRPC</strong> 推荐使用 <strong>proto3</strong>，避免出现可能的兼容问题。要编译出 rpc 相关的类需要在<code>protoc</code>的基础上使用 gRPC 的插件：<code>protoc-gen-grpc-java</code>。需要特别注意。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">"me.evthoriz.gRPC.proto"</span>;</span><br><span class="line"><span class="keyword">option</span> optimize_for = SPEED;</span><br></pre></td></tr></table></figure>
<p>由于使用了 <strong>proto3</strong> 的语法，字段默认都是 <strong>required</strong> 。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Position</span> </span>&#123;</span><br><span class="line">    <span class="built_in">float</span> lat = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">float</span> lng = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">int32</span> level = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Geohash</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> base32Str = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义 RPC 服务需要的 <strong>service</strong> 。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">GeoX</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> calcGeohash (Position) <span class="keyword">returns</span> (Geohash)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Step2-_编译_proto_文件">Step2. 编译 proto 文件</h3><p>目前 gRPC 项目用到的几个关键工具基本都是还在开发当中的最新版。<br>添加依赖项</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>grpc-all<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>0.7.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>方案一，通过 <strong>maven</strong> 配置 <code>protoc</code> 和 <code>protoc-gen-grpc-java</code> 插件。<br>方案二，下载 <strong>protoc</strong>，对于原来就在 <strong>protoc</strong> 的人来说，需要注意替换成 <code>3.0</code> 的版本。同时去官网下载<code>protoc-gen-grpc-java</code>的源码自行在本地编译。然后使用 <strong>protoc</strong> 命令时指定 <code>--plugin</code>编译，不要试图使用 IDE 的 <strong>protobuf</strong> 插件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.google.protobuf.tools<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-protoc-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">version</span>&gt;</span>0.4.2<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.0.0-alpha-3.1:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="title">protocArtifact</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">pluginId</span>&gt;</span>grpc-java<span class="tag">&lt;/<span class="title">pluginId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:0.7.1:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="title">pluginArtifact</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">execution</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="title">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="title">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">goal</span>&gt;</span>compile-custom<span class="tag">&lt;/<span class="title">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="title">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置好插件后 执行 <code>mvn compile</code> 生成 <code>Geo.java</code> 和 <code>GeoXGrpc.java</code>，前者就是 protobuf 相关的序列化类，后者就是包含了 stub class 的 rpc 服务相关的类了。这两个文件在 <code>target/generated-sources</code>下。</p>
<h3 id="Step3-_编写_Client_和_Server">Step3. 编写 Client 和 Server</h3><h4 id="客户端">客户端</h4><p>先构建一个 <strong>NettyChannel</strong>，然后实例化一个rpc service 的 <strong>BlockingStub</strong>，拥有所有的方法，通过这个 stub 调用的方法，均会通过 NettyChannel 传输出去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ChannelImpl channel = NettyChannelBuilder.forAddress(host, port)</span><br><span class="line">                .negotiationType(NegotiationType.PLAINTEXT).build();</span><br><span class="line"></span><br><span class="line">GeoXGrpc.GeoXBlockingStub blockingStub = GeoXGrpc.newBlockingStub(channel);</span><br><span class="line">        </span><br><span class="line">Geo.Position position = Geo.Position.newBuilder().setLat(<span class="number">12.12f</span>).setLng(<span class="number">45.45f</span>).setLevel(<span class="number">4</span>).build();</span><br><span class="line">Geo.Geohash geohash = blockingStub.calcGeohash(position);</span><br><span class="line">System.out.println(<span class="string">"Geohash: "</span> + geohash.getBase32Str());</span><br></pre></td></tr></table></figure>
<h4 id="服务端">服务端</h4><p>定义真正的处理类 <strong>service</strong> 实现接口，方法参数里会多一个 <strong>responseObserver</strong> 用来处理返回和关闭通道，实际是就是一个 <strong>listener</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">GeoXService</span> <span class="keyword">implements</span> <span class="title">GeoXGrpc</span>.<span class="title">GeoX</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calcGeohash</span><span class="params">(Geo.Position request, StreamObserver&lt;Geo.Geohash&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> lat = request.getLat();</span><br><span class="line">        <span class="keyword">float</span> lng = request.getLng();</span><br><span class="line">        <span class="keyword">int</span> level = request.getLevel();</span><br><span class="line">        Geo.Geohash geo = Geo.Geohash.newBuilder().setBase32Str(<span class="string">"wf3gfd3"</span>).build();</span><br><span class="line"></span><br><span class="line">        responseObserver.onValue(geo);</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在server初始化时将 service 的实例注册进去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ServerImpl server = NettyServerBuilder</span><br><span class="line">                .forPort(port)</span><br><span class="line">                .addService(GeoXGrpc.bindService(<span class="keyword">new</span> GeoXService()))</span><br><span class="line">                .build().start();</span><br></pre></td></tr></table></figure>
<h4 id="小结">小结</h4><p>总的来说，<strong>gRPC</strong> 的使用并不难，只要理解 <strong>service</strong>，<strong>stub</strong>，<strong>channel</strong>，<strong>observer</strong> 即可。安装过程可能会遇到些坑，因为目前依赖的包很多处于 <strong>alpha</strong> 或者 <strong>beta</strong> 版本，需要自行编译安装的情况比较多。等将来稳定版本出来后，环境配置应该会方便许多。</p>
<h2 id="gRPC_源码分析">gRPC 源码分析</h2><h3 id="从插件生成的代码开始">从插件生成的代码开始</h3><p><img src="\img\Grpc_gen_class.png" alt="gRPC_gen_class"></p>
<p>可以看见 <strong>GeoXGrpc</strong> 内部一共有3个 stub 类，3个 client 接口，3个静态方法。stub 类各自实现对应的 client 接口，提供对应的静态方法给调用者生成并获取实例。另外一个静态方法 <strong>bindService</strong> 是服务端注册 service 实例用的。</p>
<table>
<thead>
<tr>
<th>stub类名</th>
<th>client接口名</th>
<th>接口方法定义</th>
<th>静态方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>GeoXStub</td>
<td>GeoX</td>
<td>calcGeohash(Position,StreamObserver<geohash>):void</geohash></td>
<td>newStub(Channel)</td>
</tr>
<tr>
<td>GeoXBlockingStub</td>
<td>GeoXBlockingClient</td>
<td>calcGeohash(Position):Geohash</td>
<td>newBlockingStub(Channel)</td>
</tr>
<tr>
<td>GeoXFutureStub</td>
<td>GeoXFutureClient</td>
<td>calcGeohash(Position):ListenableFuture<geohash></geohash></td>
<td>newFutureStub(Channel)</td>
</tr>
</tbody>
</table>
<p>其中BlockingStub这个无需赘言，就是最简单的一个同步阻塞调用。所以先看看第一个和第三个有何不同。第一个是异步接口，调用方法时需要传进去一个<strong>StreamObserver</strong>, 这个对象的作用在传输层代码上增加一个listener，当特定的事件如收到消息等触发时，会调用里面的处理逻辑。看看代码，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@java</span>.lang.<span class="function">Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calcGeohash</span><span class="params">(Geo.Position request, io.grpc.stub.StreamObserver&lt;Geo.Geohash&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">    asyncUnaryCall(</span><br><span class="line">        channel.newCall(config.calcGeohash), request, responseObserver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>asyncUnaryCall 是来自类 <strong>Calls</strong> 的静态方法。它接受参数里会多一个从 channel 里新建出来的 <strong>call</strong> 对象。Calls 这个类的作用是将针对call的同步异步阻塞非阻塞的几种调用方式封装起来。毕竟可以放在jar文件里的都尽量抽象出来，使插件编译生成的代码尽量精简。<br>可以看到Calls里的方法除了构造方法外其余全是静态方法。</p>
<p><img src="\img\Calls.png" alt="Calls"></p>
<p>看调用栈，可以发现，<strong>Observer</strong> 通过一个 <strong>Adaptor</strong> 被包装成了一个<strong>Listener</strong> 送入 <strong>call</strong> 对象中。这个 Listener 其实就是将 call对象 和 observer对象封装在一起，在 Listener 触发时，调用正确的方法组合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;ReqT, RespT&gt; <span class="function"><span class="keyword">void</span> <span class="title">asyncUnaryCall</span><span class="params">(Call&lt;ReqT, RespT&gt; call, ReqT param, StreamObserver&lt;RespT&gt; observer)</span> </span>&#123;</span><br><span class="line">    asyncServerStreamingCall(call, param, observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;ReqT, RespT&gt; <span class="function"><span class="keyword">void</span> <span class="title">asyncServerStreamingCall</span><span class="params">(Call&lt;ReqT, RespT&gt; call, ReqT param, StreamObserver&lt;RespT&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">    asyncServerStreamingCall(call, param, (Listener)(<span class="keyword">new</span> Calls.StreamObserverToCallListenerAdapter(call, responseObserver)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;ReqT, RespT&gt; <span class="function"><span class="keyword">void</span> <span class="title">asyncServerStreamingCall</span><span class="params">(Call&lt;ReqT, RespT&gt; call, ReqT param, Listener&lt;RespT&gt; responseListener)</span> </span>&#123;</span><br><span class="line">    call.start(responseListener, <span class="keyword">new</span> Headers());</span><br><span class="line">    call.request(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        call.sendPayload(param);</span><br><span class="line">        call.halfClose();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">        call.cancel();</span><br><span class="line">        <span class="keyword">throw</span> Throwables.propagate(var4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看这几个 Listener 继承的抽象类，这几个方法都是在 call 里面被适时调用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Listener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Listener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 收到响应的 headers 时调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onHeaders</span><span class="params">(Headers var1)</span></span>;</span><br><span class="line">    <span class="comment">// 收到响应的 payload 时调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onPayload</span><span class="params">(T var1)</span></span>;</span><br><span class="line">    <span class="comment">// 在调用结束时调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Status var1, Trailers var2)</span></span>;</span><br><span class="line">    <span class="comment">// 这个可以无视。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先到此为止，再看看FutureStub的调用栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@java</span>.lang.<span class="function">Override</span><br><span class="line"><span class="keyword">public</span> ListenableFuture&lt;Geohash&gt; <span class="title">calcGeohash</span><span class="params">(Geo.Position request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unaryFutureCall(</span><br><span class="line">        channel.newCall(config.calcGeohash), request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能发现除了包装的 <strong>Lisener</strong> 不同，它调用的也是 asyncServerStreamingCall 这个方法。这个 Listener 更简单，作用就是触发 onClose 方法时将值 set 到 future 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;ReqT, RespT&gt; <span class="function">ListenableFuture&lt;RespT&gt; <span class="title">unaryFutureCall</span><span class="params">(Call&lt;ReqT, RespT&gt; call, ReqT param)</span> </span>&#123;</span><br><span class="line">    Calls.GrpcFuture responseFuture = <span class="keyword">new</span> Calls.GrpcFuture(call);</span><br><span class="line">    asyncServerStreamingCall(call, param, (Listener)(<span class="keyword">new</span> Calls.UnaryStreamToFuture(responseFuture)));</span><br><span class="line">    <span class="keyword">return</span> responseFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后再回头看看BlockingStub的调用栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@java</span>.lang.Override</span><br><span class="line"><span class="keyword">public</span> Geo.<span class="function">Geohash <span class="title">calcGeohash</span><span class="params">(Geo.Position request)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> blockingUnaryCall(</span><br><span class="line">      channel.newCall(config.calcGeohash), request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现它实际上只是在 unaryFutureCall 外面包了一层，阻塞等待future的返回值再返回而已。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;ReqT, RespT&gt; <span class="function">RespT <span class="title">blockingUnaryCall</span><span class="params">(Call&lt;ReqT, RespT&gt; call, ReqT param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getUnchecked(unaryFutureCall(call, param));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">        call.cancel();</span><br><span class="line">        <span class="keyword">throw</span> Throwables.propagate(var3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;V&gt; <span class="function">V <span class="title">getUnchecked</span><span class="params">(Future&lt;V&gt; future)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> future.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException var2) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(var2);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException var3) &#123;</span><br><span class="line">        <span class="keyword">if</span>(var3.getCause() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UncheckedExecutionException(var3);</span><br><span class="line">        &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(var3.getCause()</span> <span class="keyword">instanceof</span> Error) </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionError((Error)var3.getCause());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UncheckedExecutionException(var3.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小结-1">小结</h4><p>这样这三个Stub的使用场景就非常好区分了。带 Blocking 的适用于<strong>同步阻塞</strong>的，带 Future 的是<strong>同步非阻塞</strong>的，都不带的是<strong>异步</strong>的。</p>
<h3 id="源码框架分析">源码框架分析</h3><p>上面是从使用角度来分析源码，现在从全局角度来看 gRPC 的代码。主要分为两个包grpc-stub-0.7.1.jar 和 grpc-core-0.7.1.jar。分为三个模块，Stub、Channel、Transport。<br>首先是stub包，</p>
<p><img src="\img\grpc-stub.png" alt="grpc-stub"><br>重点关注三个类一个接口</p>
<ul>
<li>Calls</li>
<li>Method</li>
<li>ServerCalls</li>
<li>StreamObserver</li>
</ul>
<p>Calls 类：已经提过，提供静态方法封装对Call的各式调用。<br>StreamObserver 接口：已经提过，作为 Listener 在 Call 的各个阶段调用。<br>Method 类：</p>
<blockquote>
<p>A description of a method exposed by a service. Typically instances are created via code generation.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;RequestT, ResponseT&gt; Method&lt;RequestT, ResponseT&gt; create(MethodType type, String name, Marshaller&lt;RequestT&gt; requestMarshaller, Marshaller&lt;ResponseT&gt; responseMarshaller) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Method&lt;RequestT, ResponseT&gt;(type, name, requestMarshaller, responseMarshaller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到调用处是在插件生成的代码中，作用是封装 rpc 方法的相关信息，包括 type，name 和 parser。在服务端注册service时，bindService 用到。下面代码中的 createMethodDefination 的 第一个参数即方法信息，第二个参数是一个Handler，invoke 注册的 service 对象的对应方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeoXGrpc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> io.grpc.stub.Method&lt;Geo.Position, Geo.Geohash&gt; METHOD_CALC_GEOHASH = </span><br><span class="line">io.grpc.stub.Method.create(io.grpc.MethodType.UNARY, <span class="string">"calcGeohash"</span>,</span><br><span class="line">      io.grpc.protobuf.ProtoUtils.marshaller(Geo.Position.PARSER),</span><br><span class="line">      io.grpc.protobuf.ProtoUtils.marshaller(Geo.Geohash.PARSER));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> io.grpc.<span class="function">ServerServiceDefinition <span class="title">bindService</span><span class="params">(<span class="keyword">final</span> GeoX serviceImpl)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> io.grpc.ServerServiceDefinition.builder(<span class="string">"GeoX"</span>)</span><br><span class="line">  .addMethod(createMethodDefinition(</span><br><span class="line">      METHOD_CALC_GEOHASH,</span><br><span class="line">      asyncUnaryRequestCall(</span><br><span class="line">        <span class="keyword">new</span> io.grpc.stub.ServerCalls.UnaryRequestMethod&lt;Geo.Position,Geo.Geohash&gt;() &#123;</span><br><span class="line">          <span class="annotation">@java</span>.lang.<span class="function">Override</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(</span><br><span class="line">              Geo.Position request,</span><br><span class="line">              io.grpc.stub.StreamObserver&lt;Geo.Geohash&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">            serviceImpl.calcGeohash(request, responseObserver);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;))).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServerCalls 类：</p>
<blockquote>
<p>Utility functions for adapting {@link ServerCallHandler}s to application service implementation, meant to be used by the generated code.</p>
</blockquote>
<p>也是一个工具类，相当于 server 端的 Calls，如同客户端处 Calls 封装对 Call 的使用，ServerCalls 封装了对 ServerCall 的使用，不同的是在客户端 call 是从channel 里自建的，在服务端的 severCall 则是需要被被动处理的。上面提到的 createMethodDefination 也是被封装在它里面的。asyncUnaryRequestCall 也在上面出现过了，以 UnaryRequestMethod 接口为参数，返回一个 Handler，而实现UnaryRequestMethod 的匿名类则封装真正对 service 对象的调用。</p>
<p><img src="\img\server-Calls.png" alt="server-Calls"></p>
<p>有个东西一直没讲，这边提一下就是与 Unary 相对的 Streaming。在定义 RPC 方法时除了</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">GeoX</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> calcGeohash (Position) <span class="keyword">returns</span> (Geohash)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以有如下三种定义方式</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">GeoX</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> calcGeohash (stream Position) <span class="keyword">returns</span> (Geohash)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">GeoX</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> calcGeohash (Position) <span class="keyword">returns</span> (stream Geohash)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">GeoX</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> calcGeohash (stream Position) <span class="keyword">returns</span> (stream Geohash)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加入了 stream 的参数可以发送多个，加了 stream 的返回值可以接收多个。和用 list 的区别在于 stream 类型可以边接收边处理，边处理边返回。故看代码除了处理Unary的一套方法外，往往都有一套对streaming的处理方法。</p>
<h4 id="小结-2">小结</h4><p>grpc-stub 这个包基本上就是所有和 stub相 关的处理了。channel 和 transport 放在 grpc-core 中，下次再看。</p>
<h2 id="Ref-">Ref.</h2><p><a href="http://www.grpc.io/docs/tutorials/basic/java.html" target="_blank" rel="external">gRPC Basics - Java</a><br><a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="external">proto3</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="基于_protobuf_的_RPC_框架">基于 protobuf 的 RPC 框架</h2><p>在众多序列化器中，protobuf 的设计在速度、体积以及兼容性的考虑上折中的非常好。跨语言跨平台，简单易用，受众广泛。只是不像 thrift 有配套的 RPC 框架实现。gRPC 即是最近由 google 开源的一套基于 protobuf 的 RPC 框架，当然，它也支持 Json，Thrift，XML 等其他序列化方式。</p>
<h2 id="RPC_架构">RPC 架构</h2><p><strong>RPC</strong> 的实现思路大同小异，以动态代理为例，定义好接口，用一个代理假装实现了这个接口（真正的实现放在服务端），供客户端调用，代理内部将该方法调用封装成一个网络请求送到服务端。服务端根据参数找到对应的注册好的对象处理，返回给客户端。<br>]]>
    
    </summary>
    
      <category term="RPC" scheme="http://evthoriz.github.io/tags/RPC/"/>
    
      <category term="框架" scheme="http://evthoriz.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Geohash 算法的8个矩形]]></title>
    <link href="http://evthoriz.github.io/2015/07/02/Geohash%20%E7%AE%97%E6%B3%95%E7%9A%84%E8%BE%B9%E7%95%8C%E9%97%AE%E9%A2%98/"/>
    <id>http://evthoriz.github.io/2015/07/02/Geohash 算法的边界问题/</id>
    <published>2015-07-01T16:00:00.000Z</published>
    <updated>2015-07-03T15:21:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="基本原理及留存问题">基本原理及留存问题</h2><p>按照 geohash 的算法原理，平面空间最后是被划分为规整的矩形，每个矩形内部会拥有同一个 geohash 值。使用时只需要计算出当前点的 geohash 值，就可以从数据库中按照 geohash 这个索引获取所有这个矩形内的点的数据。这些点即被认为是当前点的附近点。然后按照距离公式计算两点距离，即可从中找到离目标最近的点。</p>
<p>问题在于，在当前点位于矩形的边界位置或者靠近边界位置时，与其最近的点可能处于边界另一侧的矩形内，这种情形下就无法匹配到最近的点。针对这种情况最直观的想法是把当前点所在矩形的周围八个矩形也包括进来，这样能保证输入的点集一定包括潜在的最近点。</p>
<a id="more"></a>
<p>那在数据库中，<code>如何找到这八个 geohash 呢</code>？根据 geohash 算法，经纬度分别被转换成了一个二进制串，然后按照奇纬偶经的规则合并两个串。再用 Base32 对合并后的二进制串进行编码。这样生成的结果也即 geohash 值对于人来说就能比较直观的拿来进行比较了。前缀重合度越高，这两个 geohash 越近。那这八个矩形是否也遵循这个直观的规律呢？不是。</p>
<p>当当前位置所靠近的边界是在划分的前期产生时，位于边界两侧的 geohash 会有巨大不同。因为按照算法的设计，<code>越早</code>的划分必定具有<code>越大</code>的权重。最简单的例子就是赤道两边的点，就算挨着，其 geohash 也会大不同。因为在第一道划分时，它们就被分开了。半球不同怎么能在一起。</p>
<p>既然无法通过geohash找到周围的8个矩形，那只能溯流而上思考了。在 Base32 编码前的那个二进制串可以么？</p>
<h2 id="定位周围8个矩形的算法">定位周围8个矩形的算法</h2><p>下面的算法是用 Processing 完成的，原因是为了能快速得到可视化的效果。代码语法同Java。</p>
<h3 id="效果图">效果图</h3><p><img src="\img\geo1.png" alt="image1"></p>
<p><img src="\img\geo2.png" alt="image2"></p>
<p>从最原始的一个平面开始将平面不断4分。将切分后的矩形存下来，如果还要继续递归切分，则从 map 里将该矩形移除。这样完整的一套切分完成后，就得到了所有的矩形，以及它们的经度二进制串和纬度二进制串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> CUTTIMES = <span class="number">4</span>;</span><br><span class="line">ArrayList&lt;Box&gt; allBoxes = <span class="keyword">new</span> ArrayList&lt;Box&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cutBox</span><span class="params">(Box box, <span class="keyword">int</span> cuttime)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cuttime &gt; CUTTIMES) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    allBoxes.remove(box);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Box leftTopBox = <span class="keyword">new</span> Box(box.x0, box.y0, box.w/<span class="number">2.0</span>, box.h/<span class="number">2.0</span>);</span><br><span class="line">  leftTopBox.addBin(box.lngSb, box.latSb, <span class="string">'0'</span>, <span class="string">'0'</span>);</span><br><span class="line">  Box rightBottomBox = <span class="keyword">new</span> Box(box.x0 + box.w/<span class="number">2.0</span>, box.y0 + box.h/<span class="number">2.0</span>, box.w/<span class="number">2.0</span>, box.h/<span class="number">2.0</span>);</span><br><span class="line">  rightBottomBox.addBin(box.lngSb, box.latSb, <span class="string">'1'</span>, <span class="string">'1'</span>);</span><br><span class="line">  Box rightTopBox = <span class="keyword">new</span> Box(box.x0 + box.w/<span class="number">2</span>, box.y0, box.w/<span class="number">2.0</span>, box.h/<span class="number">2.0</span>);</span><br><span class="line">  rightTopBox.addBin(box.lngSb, box.latSb, <span class="string">'1'</span>, <span class="string">'0'</span>);</span><br><span class="line">  Box leftBottomBox = <span class="keyword">new</span> Box(box.x0, box.y0 + box.h/<span class="number">2</span>, box.w/<span class="number">2.0</span>, box.h/<span class="number">2.0</span>);</span><br><span class="line">  leftBottomBox.addBin(box.lngSb, box.latSb, <span class="string">'0'</span>, <span class="string">'1'</span>);</span><br><span class="line">  allBoxes.add(leftTopBox);</span><br><span class="line">  allBoxes.add(rightBottomBox);</span><br><span class="line">  allBoxes.add(rightTopBox);</span><br><span class="line">  allBoxes.add(leftBottomBox);</span><br><span class="line">  cutBox(leftTopBox, cuttime+<span class="number">1</span>);</span><br><span class="line">  cutBox(rightBottomBox, cuttime+<span class="number">1</span>);</span><br><span class="line">  cutBox(rightTopBox, cuttime+<span class="number">1</span>);</span><br><span class="line">  cutBox(leftBottomBox, cuttime+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于经度一个维度来说，无论切分几次，它的左邻和右邻都只会和它相差<code>1</code>。画一下就知道它是一棵<code>有序的01满二叉树</code>。根据当前矩形的经度串，很容易就获得了它的两个东西邻接经度串。同理，可以根据其纬度串获取南北邻接纬度串。连同当前矩形的经度串和纬度串，就能组合得到周边的<code>8个矩形的二进制串</code>了。Base32 编码后的到 geohash 值，即是所需要的8个索引了。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Box&gt; findAroundBoxes(Box <span class="built_in">box</span>) &#123;</span><br><span class="line">  ArrayList&lt;Box&gt; al = <span class="keyword">new</span> ArrayList&lt;Box&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span>[] lats = convertToInt(<span class="built_in">box</span>.latSb);</span><br><span class="line">  <span class="built_in">int</span>[] lngs = convertToInt(<span class="built_in">box</span>.lngSb);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span>[] leftLats = calAdj(lats, -<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">int</span>[] rightLats = calAdj(lats, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">int</span>[] topLngs = calAdj(lngs, -<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">int</span>[] bottomLngs = calAdj(lngs, +<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">String</span>[] latlngStr = <span class="keyword">new</span> <span class="keyword">String</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">  latlngStr[<span class="number">0</span>] = joinLatLngBin(leftLats, topLngs);</span><br><span class="line">  latlngStr[<span class="number">1</span>] = joinLatLngBin(leftLats, lngs);</span><br><span class="line">  latlngStr[<span class="number">2</span>] = joinLatLngBin(leftLats, bottomLngs);</span><br><span class="line">  latlngStr[<span class="number">3</span>] = joinLatLngBin(lats, topLngs);</span><br><span class="line">  latlngStr[<span class="number">4</span>] = joinLatLngBin(lats, bottomLngs);</span><br><span class="line">  latlngStr[<span class="number">5</span>] = joinLatLngBin(rightLats, topLngs);</span><br><span class="line">  latlngStr[<span class="number">6</span>] = joinLatLngBin(rightLats, lngs);</span><br><span class="line">  latlngStr[<span class="number">7</span>] = joinLatLngBin(rightLats, bottomLngs);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">String</span> <span class="built_in">str</span> : latlngStr) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (boxMap.containsKey(<span class="built_in">str</span>)) &#123;</span><br><span class="line">      al.<span class="built_in">add</span>(boxMap.<span class="built_in">get</span>(<span class="built_in">str</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> al;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边偷了个懒，没有实现Base32编码，少做了一步，直接用二进制串做索引，不过原理是一样的。</p>
<h3 id="Base64_&amp;_Base32_简介">Base64 &amp; Base32 简介</h3><p>Base64 最早是在邮件系统里对数据进行简单加密的编码算算法，把3个 ASCII 码编码成4个 base64 字符，让人不能一眼分辨出内容。这种编码方式现在经常被用来将二进制数据展示为可辨认字符的手段。Base32 也是一个道理，将5个 ASCII 字符编码为8个 Base32 字符，对二进制来说就是把40个二进制位，编码成8个 Base32 字符，也即5个二进制位编码成一个 Base32 字符。</p>
<p>完整的代码见 <a href="https://github.com/evthoriz" target="_blank" rel="external">Github</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="基本原理及留存问题">基本原理及留存问题</h2><p>按照 geohash 的算法原理，平面空间最后是被划分为规整的矩形，每个矩形内部会拥有同一个 geohash 值。使用时只需要计算出当前点的 geohash 值，就可以从数据库中按照 geohash 这个索引获取所有这个矩形内的点的数据。这些点即被认为是当前点的附近点。然后按照距离公式计算两点距离，即可从中找到离目标最近的点。</p>
<p>问题在于，在当前点位于矩形的边界位置或者靠近边界位置时，与其最近的点可能处于边界另一侧的矩形内，这种情形下就无法匹配到最近的点。针对这种情况最直观的想法是把当前点所在矩形的周围八个矩形也包括进来，这样能保证输入的点集一定包括潜在的最近点。</p>]]>
    
    </summary>
    
      <category term="LBS" scheme="http://evthoriz.github.io/tags/LBS/"/>
    
      <category term="算法" scheme="http://evthoriz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[谈谈 Redis3.0 的集群处理]]></title>
    <link href="http://evthoriz.github.io/2015/06/28/About-Redis-Cluster/"/>
    <id>http://evthoriz.github.io/2015/06/28/About-Redis-Cluster/</id>
    <published>2015-06-27T16:00:00.000Z</published>
    <updated>2015-06-28T09:29:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="2-x时代">2.x时代</h2><p>对 Redis 的集群支持的呼声一直很高，随着前不久 Redis3.0 正式发布，网上关于 Redis Cluster 的讨论如雨后春笋，大有一统缓存界的势头。在 Redis2.0 时代，实际使用中我们也会需要用到多个 Redis 实例，分布在多台机器上，那个时候的替代方案是在客户端这边缓存所有 Redis 实例的连接（通过配置文件或者zookeeper这种中心服务管理所有 Redis配置），自己对 key 做 hash，确定每个 key 的分布，找到对应的 Redis 实例，再做操作。为了 key 的均匀分布和集群的扩展性、稳定性，一般会采用一致性哈希算法。每次扩容新增实例的时候需要更新配置信息，客户端重新加载配置信息并更新本地缓存的连接。</p>
<a id="more"></a>
<h2 id="自建集群的问题">自建集群的问题</h2><p>实际使用中主要遇到了两个问题，Redis 主从无法自动切换导致出故障时服务不可用，需要运维工程师手动切，这个实际上是有 keepalived 这种解决方案的。另一个是扩容 Redis 实例时无法灵活控制新增数量，而且需要手工操作，耗费时间人力。由于业务关系 key的量以亿计，为扩容时清理数据方便，设计分布策略时，每个实例附加了一个整型区段比如 实例A: [0,99], 实例B: [100, 199]，然后每个 key 都默默带上了一个 hash 出来的整数前缀。扩容时为了保持均匀，不得不 double 一下原来实例的数量增加 A’ 和 B’，将两个区间分别均分。A’完整拷贝A的数据，B’ 完整拷贝 B 的数据，再在新增实例内遍历一遍 key，根据整数前缀删掉不对的数据。整个过程都放在凌晨做，因为数据同步和清理过程会影响 Redis 的服务性能。清理完成后，更新 Redis 的配置文件，在客户端重新加载后开始生效。</p>
<p>总结一下就是为了自建集群使用中有两个东西需要自己处理，一个是实例出问题时的节点切换。一个是实例扩展时的数据再分配。现实是这两点处理起来都不是十分…优雅。</p>
<h2 id="3-0的集群支持">3.0的集群支持</h2><p>来看看 Redis3.0 推出的 cluster 做了什么。cluster 版本的 Redis 在启动集群服务时，节点之间互相之间会建立连接，这个节点互相发现也是通过配置文件来实现的，运行期间集群会自动将不可用 master 节点切换为它的一个 slave，保持了很好的高可用性。这个基本上是第一个问题的内置解决方案。但是对于第二个问题看上去似乎没什么革新的地方。按照官网介绍，Redis Cluster 的数据分布并没有使用一致性哈希，它引入了一个 hash slot 的概念，总共有16384（固定的）个 slots。所有 master Redis 实例将会分摊这些 slots。对 key 做 CRC16 映射到整数，然后对 16384 取模，定位到对应的 Redis 实例上。当加入节点时你还是需要手动将一部分老 Redis 的 hash slot 重新分配到新的上，所以本质上和我们采用的方法没有任何差别。尽管由于节点相互之间存在连接，slot 重新分配后数据访问和存储可以自动重定向，但是 key 的自动迁移会阻塞两个节点，对于 key 非常多的应用场景，仍然显得有些力不从心。而且 slot 得重新分配该使用什么策略能保证 key 得分配均匀呢？和我们的处理方式一样均分么？</p>
<p>在客户端方面，新的 Jedis（Java 实现的 Redis Client）已经不再需要我们自己做一致性哈希，并且节点实例的缓存都已经控制好。</p>
<p>总的来说，这次 Redis Cluster 通过节点互联支持了内部的数据访问的重定向，内部的数据迁移，也做到了在节点 fail 时的主从自动切换，相比自己处理集群来说方便了许多。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="2-x时代">2.x时代</h2><p>对 Redis 的集群支持的呼声一直很高，随着前不久 Redis3.0 正式发布，网上关于 Redis Cluster 的讨论如雨后春笋，大有一统缓存界的势头。在 Redis2.0 时代，实际使用中我们也会需要用到多个 Redis 实例，分布在多台机器上，那个时候的替代方案是在客户端这边缓存所有 Redis 实例的连接（通过配置文件或者zookeeper这种中心服务管理所有 Redis配置），自己对 key 做 hash，确定每个 key 的分布，找到对应的 Redis 实例，再做操作。为了 key 的均匀分布和集群的扩展性、稳定性，一般会采用一致性哈希算法。每次扩容新增实例的时候需要更新配置信息，客户端重新加载配置信息并更新本地缓存的连接。</p>]]>
    
    </summary>
    
      <category term="Redis" scheme="http://evthoriz.github.io/tags/Redis/"/>
    
      <category term="分布式" scheme="http://evthoriz.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从 HornetQ 讲 JMS]]></title>
    <link href="http://evthoriz.github.io/2015/06/25/%20HornetQ-and-JMS%20/"/>
    <id>http://evthoriz.github.io/2015/06/25/ HornetQ-and-JMS /</id>
    <published>2015-06-24T16:00:00.000Z</published>
    <updated>2015-06-26T03:55:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="HornetQ_简介">HornetQ 简介</h2><p>HornetQ 是众多高性能消息中间件之一，用 Java 实现，由 JBOSS 开源，支持</p>
<ul>
<li>message persistent</li>
<li>standalone &amp; embedded</li>
<li>JMS 1.1 &amp; 2.0 API</li>
</ul>
<h2 id="JMS_简介">JMS 简介</h2><p>JMS 全称 Java Message Service，是一种消息队列服务的规范。所有实现了JMS 的产品（消息中间件）都应该能够通过一个符合 JMS 规范的客户端访问。HornetQ 提供了一套 core api 用于对自己 service 的原生访问，同时也按照 JMS 规范在核心 API 上封装了一层 JMS Facade。<br>使用 JMS 可以达到的目的 </p>
<ul>
<li>系统解耦</li>
<li>异步</li>
</ul>
<p>JMS 支持的域模型    </p>
<ul>
<li>Queue</li>
<li>Pub/Sub</li>
</ul>
<a id="more"></a>
<h4 id="JMS_1-1_通用接口">JMS 1.1 通用接口</h4><table>
<thead>
<tr>
<th>JMS common interface</th>
<th>PTP domain</th>
<th>Pub/sub domain</th>
</tr>
</thead>
<tbody>
<tr>
<td>ConnectionFactory</td>
<td>QueueConnectionFactroy</td>
<td>TopicConnectionFactory</td>
</tr>
<tr>
<td>Connection</td>
<td>QueueConnection</td>
<td>TopicConnection</td>
</tr>
<tr>
<td>Destination</td>
<td>Queue</td>
<td>Topic</td>
</tr>
<tr>
<td>Session</td>
<td>QueueSession</td>
<td>TopicSession</td>
</tr>
<tr>
<td>MessageProducer</td>
<td>QueueSender</td>
<td>TopicPublisher</td>
</tr>
<tr>
<td>MessageConsumer</td>
<td>QueueReceiver,QueueBrowser</td>
<td>TopicSubscriber</td>
</tr>
</tbody>
</table>
<p>JMS 2.0 简化了 API 设计，去掉了 Connection 和 Session 转而提供一个JMSContext 用来隐式处理连接的打开和会话的建立。</p>
<h2 id="HornetQ_实战">HornetQ 实战</h2><ul>
<li>环境：MacOS</li>
<li>HornetQ版本：2.4.7.final<br>HornetQ支持嵌入式，意味着不必单独启动一个服务。</li>
</ul>
<p>首先只需要 maven 引入两个jar 文件即可。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.hornetq<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>hornetq-jms-client<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>2.4.7.Final<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.hornetq<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>hornetq-jms-server<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>2.4.7.Final<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Step1-_启动_HornetQ_服务">Step1. 启动 HornetQ 服务</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EmbeddedJMS jms = <span class="keyword">new</span> EmbeddedJMS();</span><br><span class="line">jms.start();</span><br></pre></td></tr></table></figure>
<p> <code>EmbeddedJMS</code>这个类继承自<code>EmbeddedHornetQ</code>，扮演了三个角色，</p>
<ul>
<li>JNDI server, 用于在 client 端根据名字获取服务端的对象例如 Destination</li>
<li>JMS Service, JMS API 到 Core API 的转换</li>
<li><p>HornetQ core server. 核心服务    </p>
<p>HornetQ 服务启动时会去读默认配置文件 hornetq-configuration.xml。<br>从中获取有关server的各项配置，大部分的配置项都有默认值可以不手工配置。必须配置的有 acceptor，这是HornetQ service启动时使用的接受器。此处接收器和连接器的必须是匹配的，决定了客户端和服务端通信的传输协议。</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Connectors --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">connectors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">connector</span> <span class="attribute">name</span>=<span class="value">"in-vm"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">factory-class</span>&gt;</span>org.hornetq.core.remoting.impl.invm.InVMConnectorFactory<span class="tag">&lt;/<span class="title">factory-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">connector</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">connectors</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Acceptors --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">acceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">acceptor</span> <span class="attribute">name</span>=<span class="value">"in-vm"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">factory-class</span>&gt;</span>org.hornetq.core.remoting.impl.invm.InVMAcceptorFactory<span class="tag">&lt;/<span class="title">factory-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定接收端口 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">key</span>=<span class="value">"port"</span> <span class="attribute">value</span>=<span class="value">"5446"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">acceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">acceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> HornetQ 定义了两种类型的 connector/acceptor</p>
<ul>
<li>invm: 当 client 和 server 在同一个VM中（intra Virtual Machine）</li>
<li>netty: 当 client 和 server 在不同的VM中</li>
</ul>
<p>第一步完成后 HornetQ 的服务端就正式启动了。</p>
<h3 id="Step2-_建立_HornetQ_客户端">Step2. 建立 HornetQ 客户端</h3><p>注意以下步骤的代码实现完全按照上述表格中的JMS规范</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/** ------------- 不通过 JNDI，直接创建实例 ------------- **/</span></span><br><span class="line"><span class="comment">// 创建 destination</span></span><br><span class="line">Queue queue = HornetQJMSClient.createQueue(<span class="string">"exampleQueue"</span>);</span><br><span class="line">Map&lt;String, Object&gt; connectionParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">connectionParams.put(TransportConstants.PORT_PROP_NAME, <span class="number">5446</span>);</span><br><span class="line">TransportConfiguration transportConfiguration = <span class="keyword">new</span> TransportConfiguration(InVMConnectorFactory.class.getName(), connectionParams);</span><br><span class="line"><span class="comment">// 创建 connection factory</span></span><br><span class="line">ConnectionFactory cf = HornetQJMSClient.createConnectionFactoryWithoutHA(JMSFactoryType.CF, transportConfiguration);</span><br></pre></td></tr></table></figure>
<p>创建 connectionFactory 用到的传输层配置里，可以看见使用了<code>InVMConnectorFactory</code>这个类，和 server 端配置保持一致。</p>
<p>除了这种实例化的方式创建 destination 和 connectionFactory 以外，还可以通过 JNDI 的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/** -------- 通过 JNDI 获取 ConnectionFactory 和 Queue -------- **/</span></span><br><span class="line">ConnectionFactory cf = (ConnectionFactory) jms.lookup(<span class="string">"ConnectionFactory"</span>);</span><br><span class="line">Queue queue = (Queue) jms.lookup(<span class="string">"/queue/exampleQueue"</span>);</span><br></pre></td></tr></table></figure>
<p>这需要在 hornetq-jms.xml 中配置如下，</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当使用 JNDI 来获取对象时， 需要配置以下信息 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置 connectionFactroy 的名称以及绑定的 connector --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">connection-factory</span> <span class="attribute">name</span>=<span class="value">"ConnectionFactory"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">connectors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">connector-ref</span> <span class="attribute">connector-name</span>=<span class="value">"in-vm"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">connectors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">entries</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">name</span>=<span class="value">"ConnectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">entries</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">connection-factory</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置 queue的名称 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">queue</span> <span class="attribute">name</span>=<span class="value">"exampleQueue"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">name</span>=<span class="value">"/queue/exampleQueue"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">queue</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第二步完成后，就有了 Queue 和 ConnectionFactory。</p>
<h3 id="Step3-_生产和消费数据">Step3. 生产和消费数据</h3><p>上面提到 JMS2.0 简化了API设计，不再需要使用 connection 和 session 对象来获取 producer 和 consumer。而可以直接从 JMSContext 中生成。JMSContext 实现了<code>AutoClosable</code>接口，故在 JAVA 7中，可以使用 try-with-resources 声明。</p>
<p>生产者代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// auto_acknowledge 使得每次接受到消息都会反回一个确认通知</span></span><br><span class="line"><span class="keyword">try</span> (JMSContext jmsContext = cf.createContext(JMSContext.AUTO_ACKNOWLEDGE)) &#123;</span><br><span class="line">    jmsContext.createProducer()</span><br><span class="line">        <span class="comment">// 延时两秒后发送给 server</span></span><br><span class="line">        .setDeliveryDelay(<span class="number">2000</span>)</span><br><span class="line">        <span class="comment">// 持久化到磁盘</span></span><br><span class="line">        .setDeliveryMode(DeliveryMode.PERSISTENT)</span><br><span class="line">        .send(queue, <span class="keyword">new</span> Date());            </span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (JMSRuntimeException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者同理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmsContext.createConsumer(<span class="built_in">queue</span>).receive();</span><br></pre></td></tr></table></figure>
<p>显而易见的是，关闭持久化以及使用<code>DUPS_OK_ACKNOWLEDGE</code>可以提升性能。</p>
<h2 id="Ref-">Ref.</h2><ul>
<li><a href="http://docs.jboss.org/hornetq/2.4.0.Final/docs/user-manual/html_single/index.html" target="_blank" rel="external">HornetQ 2.4.0 User-Manual</a></li>
<li><a href="http://www.ibm.com/developerworks/java/tutorials/j-jms/j-jms-updated.html" target="_blank" rel="external">Introducing the Java Message Service</a></li>
<li><a href="https://www.gitbook.com/book/kimmking/jms20cn/details" target="_blank" rel="external">JMS2.0规范中文版</a></li>
<li><a href="http://hornetq.blogspot.com/2009/10/understanding-connectors-acceptors.html" target="_blank" rel="external">Understanding Connectors &amp; Acceptors</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="HornetQ_简介">HornetQ 简介</h2><p>HornetQ 是众多高性能消息中间件之一，用 Java 实现，由 JBOSS 开源，支持</p>
<ul>
<li>message persistent</li>
<li>standalone &amp; embedded</li>
<li>JMS 1.1 &amp; 2.0 API</li>
</ul>
<h2 id="JMS_简介">JMS 简介</h2><p>JMS 全称 Java Message Service，是一种消息队列服务的规范。所有实现了JMS 的产品（消息中间件）都应该能够通过一个符合 JMS 规范的客户端访问。HornetQ 提供了一套 core api 用于对自己 service 的原生访问，同时也按照 JMS 规范在核心 API 上封装了一层 JMS Facade。<br>使用 JMS 可以达到的目的 </p>
<ul>
<li>系统解耦</li>
<li>异步</li>
</ul>
<p>JMS 支持的域模型    </p>
<ul>
<li>Queue</li>
<li>Pub/Sub</li>
</ul>]]>
    
    </summary>
    
      <category term="JMS" scheme="http://evthoriz.github.io/tags/JMS/"/>
    
      <category term="中间件" scheme="http://evthoriz.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写一个简单的爬虫]]></title>
    <link href="http://evthoriz.github.io/2015/03/15/write-a-cawler/"/>
    <id>http://evthoriz.github.io/2015/03/15/write-a-cawler/</id>
    <published>2015-03-14T16:00:00.000Z</published>
    <updated>2015-07-03T14:49:15.000Z</updated>
    <content type="html"><![CDATA[<p>一个爬虫的基本功能包括        </p>
<ul>
<li>获取网页   </li>
<li>分析内容   </li>
<li>处理结果   </li>
</ul>
<p>以 python 为例，写一个下载图片的爬虫。   </p>
<h2 id="下载网页">下载网页</h2><p>第一步获取网页内容，需要像目标服务器发送 HTTP GET 请求。有部分站点会屏蔽来自非 Web 浏览器的访问，因此构造 HTTP 请求时尽量接近于真实的浏览器请求，以减少被禁止的可能性。<br>通过浏览器的网络工具可以看到一个完整的 HTTP 请求报文，<br><img src="\img\jandan_request.png" alt="request"><br><a id="more"></a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Downloader</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, uri)</span>:</span></span><br><span class="line">        self.host = uri.split(<span class="string">"/"</span>)[<span class="number">0</span>]</span><br><span class="line">        self.conn = httplib.HTTPConnection(self.host)</span><br><span class="line">        self.headers = &#123;</span><br><span class="line">            <span class="string">"Accept-Encoding"</span>: <span class="string">"gzip"</span>,</span><br><span class="line">            <span class="string">"Accept"</span>: <span class="string">"text/html"</span>,</span><br><span class="line">            <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0"</span>,</span><br><span class="line">            <span class="string">"Referer"</span>: <span class="string">"http://jandan.net/"</span>,</span><br><span class="line">            <span class="string">"Connection"</span>: <span class="string">"keep-alive"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_content</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            path = self.uri[len(self.host):]</span><br><span class="line">            self.conn.request(<span class="string">"GET"</span>, path, <span class="keyword">None</span>, self.headers)</span><br><span class="line">            response = self.conn.getresponse()</span><br><span class="line">            <span class="keyword">if</span> response.getheader(<span class="string">"content-encoding"</span>) == <span class="string">"gzip"</span>:</span><br><span class="line">                stream = response.read()</span><br><span class="line">                html_data = gzip.GzipFile(fileobj=StringIO.StringIO(stream)).read().decode(<span class="string">"UTF-8"</span>)</span><br><span class="line">                <span class="keyword">return</span> html_data</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">print</span> Exception(<span class="string">"get_content error, path: "</span> + path)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<h2 id="分析内容">分析内容</h2><p>从 HTML 文本中提取出有用信息，对于HTML格式，尽管有现成的库 HTMLParser，但使用上不是很方便，因此用了第三方库 BeautifulSoup。通过组合条件过滤掉不需要的内容。<br>这里主要是遍历文本获取 <strong><em>img</em></strong> 标签，获取 <strong>src</strong> 属性的值。        </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, htmlData)</span>:</span></span><br><span class="line">        soup = BeautifulSoup(htmlData)</span><br><span class="line">        l = []</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> soup.find_all(<span class="string">"img"</span>):</span><br><span class="line">            <span class="keyword">if</span> item.parent.name == <span class="string">"p"</span>:</span><br><span class="line">                l.append(item[<span class="string">"src"</span>])</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>
<h2 id="处理结果">处理结果</h2><p>一般处理类需要对分析后的结果做再加工，保存文件、记录数据库，或者其他方式持久化到硬盘上。此处需要对分析得到的 url 再做一次下载，只是此次的内容变成图片。</p>
<p>在 Downloader 类的 <code>get_content()</code> 中添加如下分支：      </p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> response.<span class="function"><span class="title">getheader</span><span class="params">(<span class="string">"Content-type"</span>)</span></span> == <span class="string">"image/jpeg"</span>:</span><br><span class="line">	stream = response.<span class="function"><span class="title">read</span><span class="params">()</span></span></span><br><span class="line">	return stream</span><br></pre></td></tr></table></figure>
<p>处理类调用下载方法并保存图片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, uri, name)</span>:</span></span><br><span class="line">        downloader = Downloader(uri)</span><br><span class="line">        image_data = downloader.get_content()</span><br><span class="line">        <span class="keyword">if</span> image_data <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">with</span> open(<span class="string">"./download/"</span> + name, <span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(image_data)</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>一个爬虫的基本功能包括        </p>
<ul>
<li>获取网页   </li>
<li>分析内容   </li>
<li>处理结果   </li>
</ul>
<p>以 python 为例，写一个下载图片的爬虫。   </p>
<h2 id="下载网页">下载网页</h2><p>第一步获取网页内容，需要像目标服务器发送 HTTP GET 请求。有部分站点会屏蔽来自非 Web 浏览器的访问，因此构造 HTTP 请求时尽量接近于真实的浏览器请求，以减少被禁止的可能性。<br>通过浏览器的网络工具可以看到一个完整的 HTTP 请求报文，<br><img src="\img\jandan_request.png" alt="request"><br>]]>
    
    </summary>
    
      <category term="python" scheme="http://evthoriz.github.io/tags/python/"/>
    
      <category term="爬虫" scheme="http://evthoriz.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一致性哈希]]></title>
    <link href="http://evthoriz.github.io/2014/11/15/consistent-hashing/"/>
    <id>http://evthoriz.github.io/2014/11/15/consistent-hashing/</id>
    <published>2014-11-15T14:20:19.000Z</published>
    <updated>2015-04-14T14:18:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一致性的含义">一致性的含义</h2><p>在分布式的场景下，为了将数据分发到不同节点上，最简单的算法是通过对数据哈希取余的方式。假设有n个节点，公式为：  $hash(key) \bmod n$<br>这种方式有一个明显的弊端，当节点数变换（这在集群里经常发生），所有数据就得再次计算，重新分布，例如增加一个节点：  $hash(key) \bmod (n+1)$  很明显这个key将会跑到其他节点上去了。<br>对于数据量非常大的情形，一次迁移可能会耗时很久，给服务稳定性带来很大压力，这是不可接受的。而一致性哈希 (consistent hashing) 解决了这个问题，保证在节点数变化时，只有必要的数据发生迁移，大部分的数据的分布和原来一致。这也就是其名字里 <strong>consistent</strong> 一致性的含义。<br><a id="more"></a></p>
<h2 id="原理">原理</h2><p>一致性哈希将数据哈希到一个32位整数的连续的地址空间内，用圆环图解较易理解，所有的数据都被映射到这样一个圆环上，包括节点。节点的映射可以用物理IP的hash来做。这样数据和节点就在同一个空间内了。通过顺时针查找的方式，每个数据找到自己临近的节点，也即每个节点负责圆环上的一段地址。<br>如下图所示：<br><img src="\img\consistent-hashing-mapping.jpg" alt="映射到同一空间"><br>分布关系如图是：  </p>
<ul>
<li>A -&gt; Node2</li>
<li>B -&gt; Node3</li>
<li>C -&gt; Node3</li>
<li>D -&gt; Node1<h3 id="节点变化">节点变化</h3>由于数据和节点hash后在同一个地址空间内，且只要hash算法不变则它们在环上的地址也不变，其分布关系也应此得以稳固下来，即便有节点插入或者移出，也只有少量必要的数据需要重新分布。<br>如下图集群中新加入了一台server4：<br><img src="\img\consistent-hashing-add.jpg" alt="添加节点"><br>只有<em>Node4</em>和<em>Node2</em>之间的数据会受影响，从<em>Node3</em>上迁移到<em>Node4</em>。<h3 id="虚拟节点">虚拟节点</h3>尽管一致性哈希解决了数据再分布的问题，但是从上面的图来看，不同节点间数据的负载可能会相差非常大。因为如上文所言，每台节点负载的量大致和其上负责的地址空间长度成正比，而节点之间是无法保证均匀分布的，图中<em>Node3</em>的负载明显比<em>Node2</em>大很多。直观上容易感受，节点的数量越多，互相之间的负载差距会越小。因此引入了虚拟节点的概念。既然物理节点的数量一定，那么我们通过增加虚拟节点的方式来增加节点数。足够多的虚拟节点就能保证节点间的负载均衡。<br><img src="\img\consistent-hashing-vnode.jpg" alt="虚拟节点"><br>每个物理节点再次映射了两个虚拟节点在地址空间上。通过这种方式，三个物理节点间的负载变得均衡。  <h2 id="实现">实现</h2>这是其他人实现的一致性哈希，代码比较简单。但是基本功能都有。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.SortedMap;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHash</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashFunction hashFunction;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> numberOfReplicas;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SortedMap&lt;Integer, T&gt; circle = <span class="keyword">new</span> TreeMap&lt;Integer, T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定hash函数，虚拟节点数，物理节点集合</span></span><br><span class="line">    <span class="comment">// 将节点添加到环上</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsistentHash</span><span class="params">(HashFunction hashFunction, <span class="keyword">int</span> numberOfReplicas,</span><br><span class="line">                          Collection&lt;T&gt; nodes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hashFunction = hashFunction;</span><br><span class="line">        <span class="keyword">this</span>.numberOfReplicas = numberOfReplicas;</span><br><span class="line">        <span class="keyword">for</span> (T node : nodes) &#123;</span><br><span class="line">            add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加节点，同时添加虚拟节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfReplicas; i++) &#123;</span><br><span class="line">            circle.put(hashFunction.hash(node.toString() + i), node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除节点，同时移除虚拟节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(T node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfReplicas; i++) &#123;</span><br><span class="line">            circle.remove(hashFunction.hash(node.toString() + i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据key获取其所应当分布的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (circle.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> hash = hashFunction.hash(key);</span><br><span class="line">        <span class="keyword">if</span> (!circle.containsKey(hash)) &#123;</span><br><span class="line">            <span class="comment">// 返回hash值大于key的hash值的环上的节点集合</span></span><br><span class="line">            SortedMap&lt;Integer, T&gt; tailMap = circle.tailMap(hash);</span><br><span class="line">            <span class="comment">// 当key后面没有节点了，绕回去取环上的第一个节点</span></span><br><span class="line">            hash = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circle.get(hash);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>参考：  </strong><br><a href="https://weblogs.java.net/blog/2007/11/27/consistent-hashing" target="_blank" rel="external">consistent-hashing</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一致性的含义">一致性的含义</h2><p>在分布式的场景下，为了将数据分发到不同节点上，最简单的算法是通过对数据哈希取余的方式。假设有n个节点，公式为：  $hash(key) \bmod n$<br>这种方式有一个明显的弊端，当节点数变换（这在集群里经常发生），所有数据就得再次计算，重新分布，例如增加一个节点：  $hash(key) \bmod (n+1)$  很明显这个key将会跑到其他节点上去了。<br>对于数据量非常大的情形，一次迁移可能会耗时很久，给服务稳定性带来很大压力，这是不可接受的。而一致性哈希 (consistent hashing) 解决了这个问题，保证在节点数变化时，只有必要的数据发生迁移，大部分的数据的分布和原来一致。这也就是其名字里 <strong>consistent</strong> 一致性的含义。<br>]]>
    
    </summary>
    
      <category term="分布式" scheme="http://evthoriz.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="算法" scheme="http://evthoriz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>