<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Collection Pipeline ［译］ | yu’s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="这篇文章讲管道编程，深入浅出，推荐阅读。翻译过程中，在可能造成误解的名词上都保留了英文。

原文作者：Martin Fowler
Collection pipelines 是一种编程范式，通过把一个操作的输出当作下个操作的输入来把计算组织成序列型的操作。（常用的操作是 filter，map，和 reduce。）这种范式在函数式编程中很普通，也存在于支持 lambda 的面向对象语言中。这篇文章将用">
<meta property="og:type" content="article">
<meta property="og:title" content="Collection Pipeline ［译］">
<meta property="og:url" content="http://evthoriz.github.io/2015/07/11/Collection-Pipeline/index.html">
<meta property="og:site_name" content="yu’s blog">
<meta property="og:description" content="这篇文章讲管道编程，深入浅出，推荐阅读。翻译过程中，在可能造成误解的名词上都保留了英文。

原文作者：Martin Fowler
Collection pipelines 是一种编程范式，通过把一个操作的输出当作下个操作的输入来把计算组织成序列型的操作。（常用的操作是 filter，map，和 reduce。）这种范式在函数式编程中很普通，也存在于支持 lambda 的面向对象语言中。这篇文章将用">
<meta property="og:image" content="\img\pipeline-example-1.png">
<meta property="og:image" content="\img\pipeline-example-2.png">
<meta property="og:image" content="\img\pipeline-example-3.png">
<meta property="og:image" content="\img\pipeline-loop-1.png">
<meta property="og:image" content="\img\pipeline-loop-2.png">
<meta property="og:image" content="\img\pipeline-loop-3.png">
<meta property="og:image" content="\img\pipeline-loop-4.png">
<meta property="og:image" content="\img\pipeline-comprehensions-1.png">
<meta property="og:image" content="\img\pipeline-comprehensions-2.png">
<meta property="og:image" content="\img\pipeline-distinct.png">
<meta property="og:image" content="\img\pipeline-flatmap.png">
<meta property="og:image" content="\img\pipeline-groupby.png">
<meta property="og:image" content="\img\pipeline-map.png">
<meta property="og:image" content="\img\pipeline-sort.png">
<meta property="og:image" content="\img\pipeline-concat.png">
<meta property="og:image" content="\img\pipeline-flatten.png">
<meta property="og:image" content="\img\pipeline-difference.png">
<meta property="og:image" content="\img\pipeline-filter.png">
<meta property="og:image" content="\img\pipeline-intersection.png">
<meta property="og:image" content="\img\pipeline-reduce.png">
<meta property="og:image" content="\img\pipeline-slice.png">
<meta property="og:image" content="\img\pipeline-union.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Collection Pipeline ［译］">
<meta name="twitter:description" content="这篇文章讲管道编程，深入浅出，推荐阅读。翻译过程中，在可能造成误解的名词上都保留了英文。

原文作者：Martin Fowler
Collection pipelines 是一种编程范式，通过把一个操作的输出当作下个操作的输入来把计算组织成序列型的操作。（常用的操作是 filter，map，和 reduce。）这种范式在函数式编程中很普通，也存在于支持 lambda 的面向对象语言中。这篇文章将用">
  
    <link rel="alternative" href="/atom.xml" title="yu’s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars0.githubusercontent.com/u/2124676?v=3&amp;amp;s=460" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">evtHoriz</a></h1>
		</hgroup>

		
		<p class="header-subtitle">脑洞大开</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/evthoriz/" title="github">github</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="mail" target="_blank" href="mailto:evthoriz@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/JAVA基础/" style="font-size: 20px;">JAVA基础</a><a href="/tags/JMS/" style="font-size: 10px;">JMS</a><a href="/tags/LBS/" style="font-size: 13.33px;">LBS</a><a href="/tags/RPC/" style="font-size: 10px;">RPC</a><a href="/tags/Redis/" style="font-size: 10px;">Redis</a><a href="/tags/Spring/" style="font-size: 10px;">Spring</a><a href="/tags/python/" style="font-size: 10px;">python</a><a href="/tags/中间件/" style="font-size: 10px;">中间件</a><a href="/tags/函数式编程/" style="font-size: 13.33px;">函数式编程</a><a href="/tags/分布式/" style="font-size: 16.67px;">分布式</a><a href="/tags/框架/" style="font-size: 16.67px;">框架</a><a href="/tags/爬虫/" style="font-size: 10px;">爬虫</a><a href="/tags/算法/" style="font-size: 16.67px;">算法</a><a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">感受真理，感受爱</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">evtHoriz</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://avatars0.githubusercontent.com/u/2124676?v=3&amp;amp;s=460" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">evtHoriz</h1>
			</hgroup>
			
			<p class="header-subtitle">脑洞大开</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/evthoriz/" title="github">github</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="mail" target="_blank" href="mailto:evthoriz@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-Collection-Pipeline" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/11/Collection-Pipeline/" class="article-date">
  	<time datetime="2015-07-10T16:00:00.000Z" itemprop="datePublished">2015-07-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Collection Pipeline ［译］
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/函数式编程/">函数式编程</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>这篇文章讲管道编程，深入浅出，推荐阅读。翻译过程中，在可能造成误解的名词上都保留了英文。</p>
</blockquote>
<p><strong>原文作者：Martin Fowler</strong></p>
<p>Collection pipelines 是一种编程范式，通过把一个操作的输出当作下个操作的输入来把计算组织成序列型的操作。（常用的操作是 filter，map，和 reduce。）这种范式在函数式编程中很普通，也存在于支持 lambda 的面向对象语言中。这篇文章将用一些例子来描述这种范式时如何形成 pipeline 的，同时也是给不熟悉这种范式的同学的一个介绍，也希望能帮助人们理解当中的核心概念，在不同语言间切换时能够触类旁通。</p>
<p>Collection pipeline 是最常见最舒服的范式之一了。比如 unix 命令行中，更好的面向对象语言中，还有最近引人瞩目的函数是语言中都有出现。不同的环境下或多或少会有些不同，同一个操作有不同的命名等，但是一旦你熟悉了这个范式，那么你一定会欲罢不能的。</p>
<a id="more"></a>
<h2 id="初次见面">初次见面</h2><p>最初遇到是我接触 Unix 时。比如将设我想要找到所有在文本中出现了 “nosql” 的 bliki entries。我可以使用 grep 命令。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -l &#39;nosql&#39; bliki/entries</span><br></pre></td></tr></table></figure>
<p>然后我可能想要知道每个 entry 里包含几个单词</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -l &#39;nosql&#39; bliki/entries/* | xargs wc -w</span><br></pre></td></tr></table></figure>
<p>接着我可能希望把他们按照单词数量排序</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -l &#39;nosql&#39; bliki/entries/* | xargs wc -w | sort -nr</span><br></pre></td></tr></table></figure>
<p>然后我只要打印出前三个</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -l &#39;nosql&#39; bliki/entries/* | xargs wc -w | sort -nr | head -4 | tail -3</span><br></pre></td></tr></table></figure>
<p>和其他环境的命令行相比这个真是相当强大了。</p>
<p>后来我在使用 Smalltalk 的时候遇到了一样的范式。假设我有一个 article 对象的集合（在 someArticles 中），其中每个都有一个 tag 集合和一个单词数量。我可以这样选出那些包含了 #nosql tag 的文章：</p>
<figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someArticles <span class="method">select:</span> [ :each | each tags <span class="method">includes:</span> <span class="symbol">#nosql</span>]</span><br></pre></td></tr></table></figure>
<p>select 方法只用到一个参数，一个 Lambda 表达式（通过一对方括号定义，在 smalltalk 中则被称为一个 “block”），这个 Lambda 定义了一个 boolean 函数。它会遍历 someArticles 里的所有元素，并返回只有 lambda 判定为 true 的那些 article 集合。</p>
<p>要把结果排序，只需要这样扩展：</p>
<figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(someArticles</span><br><span class="line">    <span class="method">select:</span> [ :each | each tags <span class="method">includes:</span> <span class="symbol">#nosql</span>])</span><br><span class="line">    <span class="method">sortBy:</span> [ :a :b | a words &gt; b words]</span><br></pre></td></tr></table></figure>
<p>sortBy 方法也是以 lambda 作为参数的方法，这次代码的作用是排序那些元素。像 select 方法一样，返回的是是一个集合，因此我还能让 pipeline 继续下去：</p>
<figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">((someArticles</span><br><span class="line">    <span class="method">select:</span> [ :each | each tags <span class="method">includes:</span> <span class="symbol">#nosql</span>])</span><br><span class="line">    <span class="method">sortBy:</span> [ :a :b | a words &gt; b words])</span><br><span class="line">    <span class="method">copyForm:</span> <span class="number">1</span> <span class="method">to:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>和 unix pipeline 的核心相似点是每个参与的方法 (select, sortBy, copyFrom) 都是操作一个记录的集合并且返回一个记录的集合。在 unix 中，这个集合是流式的，那些记录一行一行的存在于流中，在 Smalltalk 中，这个集合时一些对象，但是概念是一样的。</p>
<p>最近我也用了不少 Ruby，它的语法写起 collection pipeline 来更加方便，因为我不需要老是把上一个 pipeline 阶段用括号括起来。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .select&#123;|a| a.tags.<span class="keyword">include</span>?(<span class="symbol">:nosql</span>)&#125;</span><br><span class="line">    .sort_by&#123;|a| a.words&#125;</span><br><span class="line">    .take(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>将 collection pipeline 写成方法链的形式在面向对象的语言中是一种非常自然的方式。但是用函数嵌套也是能够做到的。</p>
<p>回头看看一些基本概念，我们看看在 common lisp 中如何建立这样一个相似的 pipeline。我可以把每一篇文章存在一个叫 articles 的数据结构中，这样我就能通过函数比如 article-words 和 article-tags 来获取它的属性了。函数 some-articles 返回最早的用来作为初始值的那些文章。</p>
<p>第一步是选择 nosql 的 articles。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">remove-if-not</span></span><br><span class="line">    <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">member</span> <span class="quoted">'nosql</span> <span class="list">(<span class="keyword">article-tags</span> x)</span>)</span>)</span></span><br><span class="line">    <span class="list">(<span class="keyword">some-articles</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>用 Smalltalk 和 Ruby 里的那个例子，我使用了函数 remove-if-not 来同时处理列表和 lambda 。然后我们继续扩展，增加排序功能，还是用一个 lambda：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">sort</span></span><br><span class="line">    <span class="list">(<span class="keyword">remove-if-not</span></span><br><span class="line">        <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">member</span> <span class="quoted">'nosql</span> <span class="list">(<span class="keyword">articles-tags</span> x)</span>)</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">some-articles</span>)</span>)</span></span><br><span class="line">    <span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">a</span> b)</span> <span class="list">(<span class="keyword">&gt;</span> <span class="list">(<span class="keyword">article-words</span> a)</span> <span class="list">(<span class="keyword">article-words</span> b)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>然后是选择 top 3，使用 subseq：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">subseq</span></span><br><span class="line">    <span class="list">(<span class="keyword">sort</span></span><br><span class="line">        <span class="list">(<span class="keyword">remove-if-not</span></span><br><span class="line">            <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">member</span></span> <span class="variable">'nosql</span> <span class="list">(<span class="keyword">article-taggs</span> x)</span>)</span>)</span></span><br><span class="line">            <span class="list">(<span class="keyword">some-articles</span>)</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">a</span> b)</span> <span class="list">(<span class="keyword"><span class="built_in">&gt;</span></span> <span class="list">(<span class="keyword">article-words</span> a)</span> <span class="list">(<span class="keyword">article-words</span> b)</span>)</span>)</span>)</span></span><br><span class="line"><span class="number">0</span> <span class="number">3</span>)</span></span><br></pre></td></tr></table></figure>
<p>pipline 就是这样了，它是如此优美的一步一步建立起来的。然而问题是，当你第一眼看到这完整的表达式时，对你来说，它的 pipeline 的本质清晰么。unix pipeline 和 smalltalk/ruby pipeline 的函数是有一个线性的顺序的，它的顺序和它的执行顺序一致。你可以很容易就看穿数据是如何从左上角开始逐个的应用那些 fliter 到达底部的。Lisp 使用了嵌套函数的方式，因此你不得不从最内层开始往外阅读。</p>
<p>近代 lisp 方言，Clojure 避免了这个问题，可以写成如下形式：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">-&gt;&gt;</span></span> <span class="list">(<span class="keyword">articles</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">filter</span></span> #<span class="list">(<span class="keyword">some</span> #<span class="collection">&#123;<span class="attribute">:nosql</span>&#125;</span> <span class="list">(<span class="attribute">:tags</span> %)</span>)</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">sort-by</span></span> <span class="attribute">:words</span> &gt;)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">take</span></span> <span class="number">3</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>符号 “-&gt;&gt;” 是一个 threading macro，它使用了 lisp 强大的宏 (macro) 能力来将每个表达式的值串到下一个表达式上。 在你的库中遵循该约束，你就能将一系列的嵌套函数给转换成线性的 pipeline。</p>
<p>最近时常能听到函数式语言的粉丝们夸赞 collection pipeline，说它是面向对象语言不具有的强大特性。作为一个老 smalltalk 程序员，我实在是有些觉得这些争论无聊的很，因为在 smalltalk 的使用者老早就到处在用了。之所以人们会有这样的误解是因为流行的面向对象语言比如 C++, Java, C# 没有继承 smalltalk 对 lambda 的使用，故而也没有很多操作集合的方法来支持 pipeline 范式。结果就是对很多OO程序员来说，完全不了解 collection pipeline。但是像我一样的 smalltalk 程序员转型成 Java 程序员时，对于 Java 缺少这个特性是非常不爽的。有很多人尝试利用 Java 里可以用的东西去建造一个 collection pipeline；毕竟，对于 OOer 来说，一个 function 仅仅是一个带有方法的类罢了。但是生成的代码确实一团乱麻，就算是个中高手也不得不放弃了。Ruby 对 pipeline 优良的支持是我从 2000 年左右开始使用它的主要原因。 Smalltalk 里的好东西真是让人怀念啊。</p>
<p>最近 lambda 表达式逐渐摆脱了作为一种高级特性且基本不用的名声。主流语言如 C#，好几年前就已经支持它，甚至连 Java 最后也支持了。因此现在 collection pipeline 说不定又能出现在众多语言中了。</p>
<h2 id="定义_Collection_Pipeline">定义 Collection Pipeline</h2><p>我把 Collection Pipeline 当作一种模块化和组合化软件的范式。像大多数范式一样，它经常出现，但看上去却好像又变了个模样。不过，只要你掌握了这范式底层的思想，那你在新环境中也是能够马上认出它的。</p>
<p>Collection pipeline 会陈列出一系列的操作，它们互相传递集合。每个操作都是以一个集合作为输入，并且生出另一个集合（除了最后一个操作，可能作为终结只生成一个值了）。每个独立的操作都很简单，但是把它们串起来可以产生复杂的行为，就像你在现实生活中把管道互相插起来一样。</p>
<p>Collection Pipeline 是 Pipes and Filters 模式的一种特例。Pipes and Filters 里的 filter 对应 Collection Pipeline 里的操作 (operation)，我会用 operation 而非 filter，因为 filter 不过是众多 operation 之一罢了。另一方面，collection pipeline 是一种特别但是通用的组合高阶的处理顺序数据结构的函数的方案。</p>
<p>操作 (operations) 和操作间传递的集合 (collections)，在不同的语境中有不同的形式。</p>
<p>在 Unix 中，collection 是一个包含多行的文本文件。每一行包含多个值，通过空格分隔。每个值的含义由它的顺序决定。operations 是 unix 进程，collections 则由 pipeline 操作符组合起来。pipeline 操作符用上一个处理的标准输出作为下一个的标准输入。</p>
<p>在面向对象的语言中，collections 是一个集合类 (list, array, set, etc)。集合里的所有对象就是 collection 里的项，这些对象可能也是集合或者包含更多的集合。operations 则是定义在集合类里的方法 － 通常是定义在高层的父类里的。 operations 则是通过一个方法链组合起来的。</p>
<p>在函数式语言中，collections 和面向对象语言中的 collections 差不多。然而不像面向对象里，item 是对象，函数式里，item 是集合范型本身，比如会用一个 hashmap 。顶层集合的元素可能是集合本身，并且 hashmap 的元素也可能是集合 － 所以像面向对象的例子那样我们可以组合出任意层的复杂结构。operations 就是 functions ，它们可以嵌套组合，也可以通过一个能够线性表达的操作符来组合，就像 Clojure 的剪头操作符一样。</p>
<p>这个范型在其他地方也有出现。当关系型模型 (relational model) 最初定义的时候，提出了关系关系代数 (relational algebra)，你可以理解为一种 collection pipeline，中间的集合通过关系约束。但是 SQL 并没有使用 pipeline 方式，而是通过了更像是 comprehensions 的途径（这个后面讨论）。</p>
<p>像这样使用一系列的变换的观念是一种常见的组织程序结构的方式 － 是 Pipes and Filter 构建模式的成功。</p>
<p>编译器通常是这样工作的，从源代码，到句法树，经过各种优化，然后生成输出的代码。不同的是 collection pipeline 在不同阶段间传递的是数据结构时是集合，因而产生一些特定的操作通用的 pipeline 的 operations。</p>
<h2 id="探索更多的_pipelines_和_operations">探索更多的 pipelines 和 operations</h2><p>上面用到例子只设计了一些通用的 operation，现在我们来看看更多的例子。我会用 ruby 来讲解，因为最近用的比较多。但是其他支持这种范式语言一样可以写出一样的 pipeline 。</p>
<h4 id="Getting_total_word_counts_(map_and_reduce)">Getting total word counts (map and reduce)</h4><p><img src="\img\pipeline-example-1.png" alt="example-1"></p>
<p>最终要的两种 pipeline operation 可以用一个很简单的任务来解释：如何获取列表里所有文章的单词个数。第一个 operation 是 <strong>map</strong>，它会返回一个集合，这些集合里的元素是通过将所有输入元素应用 lambda 表达式计算出来的。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map&#123;|i| i*i&#125; <span class="comment"># =&gt; [1, 4, 9]</span></span><br></pre></td></tr></table></figure>
<p>因此假如我们使用这个方法，那么就能将文章列表转换成每一篇文章的单词数的列表了。然后，我们就可以应用另一个 operation 了：<strong>reduce</strong>。reduce 可以将一个输入集合转变为一个单一输出。这种功能的函数经常被称为 reduction。Reductions 经常减到剩一个值，这个通常是在 collectin pipeline 的最后一步发生。Ruby 里一般的 reduce 函数会用拥有两个变量的 lambda 表达式作为参数。一个变量是元素，另一个是累计器。reduction 中每一步都会将累计器的值设置为新元素和 lambda 的运算结果。可以像这样对列表求和：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce&#123;|acc, each| acc + each&#125; <span class="comment"># =&gt; 6</span></span><br></pre></td></tr></table></figure>
<p>有了这两种 operation，计算单词总数不过是两步 pipeline 而已：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .map&#123;|a| a.words&#125;</span><br><span class="line">    .reduce&#123;|acc, w| acc + w&#125;</span><br></pre></td></tr></table></figure>
<p>第一步 map 是将一个文章列表转换成了单词数列表。第二步对单词列表做了一次 reduction ，得到一个和。</p>
<p>提一下，构建 collection pipeline 时有多种方式来表达函数，可以用 lambda 表达式，也可以用函数名。用 clojure 来写这个 pipeline 是这样的：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">-&gt;&gt;</span></span> <span class="list">(<span class="keyword">articles</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">map</span></span> <span class="attribute">:words</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">reduce</span></span> +)</span>)</span></span><br></pre></td></tr></table></figure>
<p>在这个例子里只需要函数名就可以了。传递给 map 的函数会对所有输入集合的元素做运算， reduce 则作用于每个元素和累计器。在 ruby 里也可以这么做，这边 words 是一个定义在 collection 里的方法。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .<span class="function"><span class="title">map</span><span class="params">(&amp;:words)</span></span></span><br><span class="line">    .<span class="function"><span class="title">reduce</span><span class="params">(:+)</span></span></span><br></pre></td></tr></table></figure>
<p>一般来说使用函数名会更加简短些，但这样你只能调用每个对象里的简单方法。使用 lambda 能为你使用复杂句法时提供更多灵活性。用 ruby 时我一般用 lambda 多些，用 clojure 则能用函数名就用。用哪种都可以。</p>
<h4 id="获取每种_type_的_articles_的数量">获取每种 type 的 articles 的数量</h4><p><img src="\img\pipeline-example-2.png" alt="example-2"></p>
<p>下一个例子，看看每种 type 的 articles 有多少。输出应该是一个 hashmap，key 为 type ，value 为 对应类型的 article 的数量。</p>
<p>首先需要将 articles 按照 type 分组。这里能用上的操作符 (operator) 叫做 group-by。这个操作会将元素放进 hash 表中，用提供的代码处理这个元素得到的结果作为索引。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .group_by &#123;|a| a.type&#125;</span><br></pre></td></tr></table></figure>
<p>现在需要做的是取得每组 articles 的数量。这对于 map 来说太简单了，只要对每个元素运行一下 count 就可以了。但是复杂的是需要返回的数据包括：分组名称和数量。还有一个相干的问题是，前面的例子里 map 的参数都是列表，现在 group-by 出来的是 hashmap。</p>
<p>对于collection pipeline 来说，这种情况是很常见的。我们传递的 collections 可能是 list 也有可能是 hash。我们应当学会如何轻易的转换两者。技巧是，将 hash 当作 pair 的 list － 每一个 pair 包括 key 和对应的 value。当然不同语言里 hash 里的元素如何展现可能有所不同，但是一个通用的方法是将每个 hash 元素当成一个二元数组：[key, value]。</p>
<p>Ruby 就是这么做的，并且它提供了一个 to_h 方法来方便我们把 pair 的数组转换为 hash。因此我们可以这样应用 map：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .group_by &#123;|a| a.type&#125;</span><br><span class="line">    .map &#123;|pair| [pair[<span class="number">0</span>], pair[<span class="number">1</span>].size]&#125;</span><br><span class="line">    .to_h</span><br></pre></td></tr></table></figure>
<p>在 collection pipeline 里，hash 和 array 之间这样转换是很常见的。用 array 的索引来获取 pair 不太自然，因此 ruby 允许我们直接把 pair 解构成两个变量。像这样：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .group_by &#123;|a| a.type&#125;</span><br><span class="line">    .map &#123;|key, value| [key, value.size]&#125;</span><br><span class="line">    .to_h</span><br></pre></td></tr></table></figure>
<p>解构函数式编程语言中一种普通的技术，因为它们老要这样传递 list-of-hash 样的数据结构。Ruby 的解构语法相当精简，但是也足够达到这个简单的目的了。</p>
<p>用 clojure 也是差不多类似的：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">-&gt;&gt;</span></span> <span class="list">(<span class="keyword">articles</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword">group-by</span> <span class="attribute">:type</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">map</span></span> <span class="list">(<span class="keyword"><span class="built_in">fn</span></span> <span class="collection">[<span class="collection">[k v]</span>]</span> <span class="collection">[k <span class="list">(<span class="keyword"><span class="built_in">count</span></span> v)</span>]</span>)</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">into</span></span> <span class="collection">&#123;&#125;</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<h4 id="获取每个_tag_对应的文章数">获取每个 tag 对应的文章数</h4><p><img src="\img\pipeline-example-3.png" alt="example-3"></p>
<p>下一个 pipeline 我们需要统计每个 tag 对应的文章数，和单词数。要完成这个目标需要重新组织数据结构。顶层的项是 article，每个 article 可能包含 很多的 tag。我们需要把数据结构解开，让 tag 到顶层。一种想法是，这么做实际是在倒置一种多对多关系，因此 tag 才应该是聚合的元素。</p>
<p>重新组织 pipeline 开始的 collection 的层级解构会让事情变得复杂，但是仍然还是在该范式的掌控之内的。要这么做得把步骤细分一下，把一个完整的转换分成一份一份再串起来会更加易懂些。这也正是 collection pipeline 的思想所在。</p>
<p>第一步是关注 tag，解开数据结构我们才能为每个 tag 得到一条记录。这和你在关系型数据库中通过一张关系表展现一个多对多的关系十分相似。要这么做我将创建一个 lambda 表达式，以 article 为参数，产出一个 pair（包含 tag 和 article），然后将这个 lambda 作用于所有的 articles。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .map &#123;|a| a.tags.map&#123;|tag| [tag, a]&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>这会产生如下的数据结构：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[</span><br><span class="line">    <span class="collection">[ <span class="collection">[<span class="attribute">:nosql</span>, Article<span class="list">(<span class="keyword">NoDBA</span>)</span>]</span></span><br><span class="line">      <span class="collection">[<span class="attribute">:people</span>, Article<span class="list">(<span class="keyword">NoDBA</span>)</span>]</span></span><br><span class="line">      <span class="collection">[<span class="attribute">:orm</span>, Article<span class="list">(<span class="keyword">NoDBA</span>)</span>]</span></span><br><span class="line">    ]</span></span><br><span class="line">    <span class="collection">[ <span class="collection">[<span class="attribute">:nosql</span>, Article<span class="list">(<span class="keyword">Infodeck</span>)</span>]</span></span><br><span class="line">      <span class="collection">[<span class="attribute">:writing</span>, Article<span class="list">(<span class="keyword">Infodeck</span>)</span>]</span></span><br><span class="line">    ]</span></span><br><span class="line">    # more rows of articles</span><br><span class="line">]</span></span><br></pre></td></tr></table></figure>
<p>这个 map 的结果是一个 pair 的列表的列表。为每个 article 产生了一个嵌套列表。那个嵌套列表太碍事了，所以用一个 flatten 操作，将它平铺开来。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .map &#123;|a| a.tags.map&#123;|tag| [tag, a]&#125;&#125;</span><br><span class="line">    .flatten <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>生成</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[</span><br><span class="line">    <span class="collection">[<span class="attribute">:nosql</span>, Article<span class="list">(<span class="keyword">NoDBA</span>)</span>]</span></span><br><span class="line">    <span class="collection">[<span class="attribute">:people</span>, Article<span class="list">(<span class="keyword">NoDBA</span>)</span>]</span></span><br><span class="line">    <span class="collection">[<span class="attribute">:orm</span>, Article<span class="list">(<span class="keyword">NoDBA</span>)</span>]</span></span><br><span class="line">    <span class="collection">[<span class="attribute">:nosql</span>, Article<span class="list">(<span class="keyword">Infodeck</span>)</span>]</span></span><br><span class="line">    <span class="collection">[<span class="attribute">:writing</span>, Article<span class="list">(<span class="keyword">Infodeck</span>)</span>]</span></span><br><span class="line">    # more rows of articles</span><br><span class="line">]</span></span><br></pre></td></tr></table></figure>
<p>这种对没用的嵌套做平铺操作非常常见，因此大部分语言都内置了这样一种 flat-map 操作来一步完成。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .flat_map &#123;|a| a.tags.map&#123;|tag| [tag, a]&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>现在有了这样一个关于 pair 的 list，后面的操作就简单了，根据 tag 分组即可。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .flat_map &#123;|a| a.tags.map&#123;|tag| [tag, a]&#125;&#125;</span><br><span class="line">    .group_by &#123;|pair| pair.first&#125;</span><br></pre></td></tr></table></figure>
<p>生成</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;</span><br><span class="line">    <span class="attribute">:people:</span></span><br><span class="line">      <span class="collection">[  <span class="collection">[<span class="attribute">:people</span>, Article<span class="list">(<span class="keyword">NoDBA</span>)</span>]</span> ]</span></span><br><span class="line">    <span class="attribute">:orm:</span></span><br><span class="line">      <span class="collection">[  <span class="collection">[<span class="attribute">:orm</span>, Article<span class="list">(<span class="keyword">NoDBA</span>)</span>]</span></span><br><span class="line">         <span class="collection">[<span class="attribute">:orm</span>, Article<span class="list">(<span class="keyword">NoDBA</span>)</span>]</span></span><br><span class="line">      ]</span></span><br><span class="line">    <span class="attribute">:writing:</span></span><br><span class="line">      <span class="collection">[  <span class="collection">[<span class="attribute">:writing</span>, Article<span class="list">(<span class="keyword">Infodeck</span>)</span>]</span>  ]</span></span><br><span class="line">    # more records</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>又有嵌套层了，因为每个关联关系都是一个 key/article pair 的 list，而不是article 的 list。这个可以通过将 pair 映射成 article 来除去。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">some_article</span><br><span class="line">    .flat_map &#123;|a| a.tags.map[|tag| [tag, a]&#125;</span><br><span class="line">    .group_by &#123;|pair| pair.first&#125;</span><br><span class="line">    .map &#123; |k, pairs| [k, pairs.map&#123;|p| p.last&#125;]&#125;</span><br></pre></td></tr></table></figure>
<p>生成</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;</span><br><span class="line">    <span class="attribute">:people:</span>    <span class="collection">[ Article<span class="list">(<span class="keyword">NoDBA</span>)</span> ]</span></span><br><span class="line">    <span class="attribute">:orm:</span>       <span class="collection">[ Article<span class="list">(<span class="keyword">NoDBA</span>)</span>, Article<span class="list">(<span class="keyword">OrmHate</span>)</span> ]</span></span><br><span class="line">    <span class="attribute">:writing:</span>   <span class="collection">[ Article<span class="list">(<span class="keyword">Infodeck</span>)</span> ]</span></span><br><span class="line">    # more records</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>现在做到了把数据结构转换好了，反转了多对多的关系。要得到想要的结果只需要一个简单的 map 来提取所需要的数据即可。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .flat_map &#123;|a| a.tags.map[|tag| [tag, a]&#125;</span><br><span class="line">    .group_by &#123;|pair| pair.first&#125;</span><br><span class="line">    .map &#123;|k, pairs| [k, pairs.map&#123;|p| p.last&#125;]&#125;</span><br><span class="line">    .map &#123;|k, v| [k, &#123;<span class="symbol">articles:</span> v.size, <span class="symbol">words:</span> v.map(&amp;<span class="symbol">:words</span>).reduce(<span class="symbol">:+</span>)&#125;]&#125;</span><br><span class="line">    .to_h</span><br></pre></td></tr></table></figure>
<p>生成一个 hashes 的 hash：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">:nosql:</span></span><br><span class="line"><span class="code">    :articles: 4</span></span><br><span class="line"><span class="code">    :words: 3906</span></span><br><span class="line"><span class="attribute">:people:</span></span><br><span class="line"><span class="code">    :articles: 1</span></span><br><span class="line"><span class="code">    :words: 561</span></span><br><span class="line"><span class="attribute">:orm:</span></span><br><span class="line"><span class="code">    :articles: 2</span></span><br><span class="line"><span class="code">    :words: 2279</span></span><br><span class="line"><span class="attribute">:writing:</span></span><br><span class="line"><span class="code">    :articles: 1</span></span><br><span class="line"><span class="code">    :words: 1145</span></span><br><span class="line"><span class="attribute">:ruby:</span></span><br><span class="line"><span class="code">    :articles: 1</span></span><br><span class="line"><span class="code">    :words: 1313</span></span><br><span class="line"><span class="attribute">:ddd:</span></span><br><span class="line"><span class="code">    :articles: 1</span></span><br><span class="line"><span class="code">    :words: 482</span></span><br></pre></td></tr></table></figure>
<p>用 Clojure 做也是差不多的：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">-&gt;&gt;</span></span> <span class="list">(<span class="keyword">articles</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">mapcat</span></span> #<span class="list">(<span class="keyword"><span class="built_in">map</span></span> <span class="list">(<span class="keyword"><span class="built_in">fn</span></span> <span class="collection">[tag]</span> <span class="collection">[tag %]</span> <span class="list">(<span class="attribute">:tags</span> %)</span>)</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword">group-by</span> first)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">map</span></span> <span class="list">(<span class="keyword"><span class="built_in">fn</span></span> <span class="collection">[<span class="collection">[k v]</span>]</span> <span class="collection">[k <span class="list">(<span class="keyword"><span class="built_in">map</span></span> last v)</span>]</span>)</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">map</span></span> <span class="list">(<span class="keyword"><span class="built_in">fn</span></span> <span class="collection">[<span class="collection">[k v]</span>]</span> <span class="collection">[k <span class="collection">&#123;<span class="attribute">:articles</span> <span class="list">(<span class="keyword"><span class="built_in">count</span></span> v)</span>, <span class="attribute">:words</span> <span class="list">(<span class="keyword"><span class="built_in">reduce</span></span> + map <span class="attribute">:words</span> v)</span>)&#125;</span>&#125;</span>)</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">into</span></span> <span class="collection">&#123;&#125;</span>)</span></span></span></span><br></pre></td></tr></table></figure>
<p><em>Clojure’s flat-map operation is called mapcat.</em></p>
<p>建立起这样一个复杂的 pipeline 相当不容易。我觉得最简单的方法是每一次只专心做一步，仔细检查输出的 collection 是否正确，然后才能保证后面可以正确继续下去。要看输出对不对可能需要输出的格式有良好缩进易于阅读。或者你也可以先写测试，用一些简单的断言来判断数据是否正确，再继续追加 pipeline 的同时演进你的测试代码。</p>
<p>建立 pipeline 的过程是一步一步的，但是直接看最后的代码却难以理解。因为前面一大部分是在重新组织数据结构。因此我把这部分抽离出来到一个函数里了。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">defn</span></span> index-by <span class="collection">[f, seq]</span></span><br><span class="line">    <span class="list">(<span class="keyword"><span class="built_in">-&gt;&gt;</span></span> seq</span><br><span class="line">         <span class="list">(<span class="keyword"><span class="built_in">mapcat</span></span> #<span class="list">(<span class="keyword"><span class="built_in">map</span></span> <span class="list">(<span class="keyword"><span class="built_in">fn</span></span> <span class="collection">[key]</span> <span class="collection">[key %]</span>)</span> <span class="list">(<span class="keyword">f</span> %)</span>)</span>)</span></span><br><span class="line">         <span class="list">(<span class="keyword">group-by</span> first)</span></span><br><span class="line">         <span class="list">(<span class="keyword"><span class="built_in">map</span></span> <span class="list">(<span class="keyword"><span class="built_in">fn</span></span> <span class="collection">[<span class="collection">[k v]</span>]</span> <span class="collection">[k <span class="list">(<span class="keyword"><span class="built_in">map</span></span> last v)</span>]</span>)</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">defn</span></span> total-words <span class="collection">[articles]</span> </span><br><span class="line">    <span class="list">(<span class="keyword"><span class="built_in">reduce</span></span> + <span class="list">(<span class="keyword"><span class="built_in">map</span></span> <span class="attribute">:words</span> articles)</span>)</span>)</span></span><br><span class="line">  </span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">-&gt;&gt;</span></span> <span class="list">(<span class="keyword">articles</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword">index-by</span> <span class="attribute">:tags</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">map</span></span> <span class="list">(<span class="keyword"><span class="built_in">fn</span></span> <span class="collection">[<span class="collection">[k v]</span>]</span> <span class="collection">&#123;k <span class="collection">&#123;<span class="attribute">:articles</span> <span class="list">(<span class="keyword"><span class="built_in">count</span></span> v)</span>, <span class="attribute">:words</span> <span class="list">(<span class="keyword">total-words</span> v)</span>&#125;</span>&#125;</span>)</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">into</span></span> <span class="collection">&#123;&#125;</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>同时我也可以把计单词数的代码抽象出来。抽象出因子会增加行数，但是我觉得这让代码更易理解，是值得的。简短强大的代码是不错，但是简短只有建立于清晰之上时才有价值。</p>
<p>在面向对象语言中，要这么做需要添加一个函数到 collection class 中，因为在 pipeline 中，你只能使用 collection 内建的函数。在 ruby 里，可以这样写：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> </span>invert_index_by &amp;proc</span><br><span class="line">    flat_map &#123;|e| proc.call(e).map &#123;|key| [key, e]&#125;&#125;</span><br><span class="line">      .group_by &#123;|pair| pair.first&#125;</span><br><span class="line">      .map &#123;|k,pairs| [k, pairs.map &#123;|p| p.last&#125;]&#125;         </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这里我给它换了个名字，因为 index_by 在本地函数的语境内已经有意义了，但是对于 collection 类里的一个泛型方法来说，其实也无所谓。需要在 collection class 里添加方法是 OO 语言的负作用。有些平台根本不允许你修改库里的类，使得这种构建完全不可行。有些则允许你像这样通过 monkey patching 来修改这些类，但是这会在全局范围内造成类库 API 的变动，所以你要格外小心。最好的选择是像 C# 里的扩展机制，或者是 ruby 里的只在一个小的命名空间里的上下文中起效的细微改变。但是相比定义一个函数，使用 monkey-patch 还是有一对繁文缛节要遵守。</p>
<p>一旦定义好方法了，我们就可以重构这个 pipeline，让它像 clojure 那样。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">total_words = -&gt; (a) &#123;a.map(&amp;<span class="symbol">:words</span>).reduce(<span class="symbol">:+</span>)&#125;</span><br><span class="line">some_articles</span><br><span class="line">    .invert_index_by &#123;|a| a.tags&#125;</span><br><span class="line">    .map &#123;|k,v| [k, &#123;<span class="symbol">articles:</span> v.size, <span class="symbol">words:</span> total_words.call(v)&#125;]&#125;</span><br><span class="line">    .to_h</span><br></pre></td></tr></table></figure>
<p>这里我把统计词数的代码也抽象出来了，不过在 ruby 里这样不是很有效率，因为我不得不显示的调用我创建的函数。虽然不多，但是还是增加了<br>一点阅读难度。我可以把他定义成一个类方法，这样就省去了调用的语句。不过我会再走远些，添加一个类来包含这个求和函数。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleSummary</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> </span>initialize articles</span><br><span class="line">    <span class="variable">@articles</span> = articles</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> </span>size</span><br><span class="line">    <span class="variable">@articles</span>.size</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> </span>total_words</span><br><span class="line">    <span class="variable">@articles</span>.map&#123;|a| a.words&#125;.reduce(<span class="symbol">:+</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>使用方式如下：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">some_articles</span><br><span class="line">    .invert_index_by &#123;|a| a.tags&#125;</span><br><span class="line">    .map &#123;|k,v| [k, <span class="constant">ArticleSummary</span>.new(v)]&#125;</span><br><span class="line">    .map &#123;|k,a| [k, &#123;<span class="symbol">articles:</span> a.size, <span class="symbol">words:</span> a.total_words&#125;]&#125;</span><br><span class="line">    .to_h</span><br></pre></td></tr></table></figure>
<p>可能很多人觉得为了抽象出几个函数就引入一个新的类有点太重了。我自己写写本地代码时是没那么在意啦。但是在这例子中我是不很愿意的，因为真的只有一个统计单词的函数值得抽离出来。</p>
<h2 id="其他方案">其他方案</h2><p>Collection pipeline 范式不是唯一的手段，有一个替代方案是大多数人在一般情况下都在使用的：循环。</p>
<h4 id="使用循环">使用循环</h4><p>以获取 top 3 NoSQl articles 为例：</p>
<p><img src="\img\pipeline-loop-1.png" alt="pipeline-loop-1"></p>
<p>collection pipline 的版本更短一些，并且在我看来更加基础易懂，因为我比较熟嘛。换句话说，循环的版本也不差。</p>
<p>下面是统计单词数的例子：</p>
<p><img src="\img\pipeline-loop-2.png" alt="pipeline-loop-2"></p>
<p>分组的例子：</p>
<p><img src="\img\pipeline-loop-3.png" alt="pipeline-loop-3"></p>
<p>每个 tag 的文章数：</p>
<p><img src="\img\pipeline-loop-4.png" alt="pipeline-loop-4"></p>
<p>这下 collection pipeline 要简短多了。不过这种比较也不是十分公平啦。</p>
<h4 id="使用推导式_(Comprehensions)">使用推导式 (Comprehensions)</h4><p>有些语言提供了推导，通常称作列表推导 (list comprehensions)，就像一个简化的 collection pipelines。假设需要获取所有长度超过1000的文章的标题，我会使用 coffeescript 来演示列表推导，用原生 Javascript 演示 collection pipelines。</p>
<p><img src="\img\pipeline-comprehensions-1.png" alt="pipeline-comprehensions-1"></p>
<p>不同语言之间列表推导的能力各不相同，不过你可以把它当作是一种把操作序列表达成一句语句的方法。这种想法阐明了什么时候该使用它。它只能被用于一些特定的 pipeline collections 的组合，因此灵活性并不强。意味着它只是为了一些通用情形而定义的，因此在很多情形中它们只是一个选项罢了。</p>
<p>comprehensions 也可以被放到 pipelines 中，作为一个 operation。因此，要获取所有超过千字的文章的单词数可以这样写：</p>
<p><img src="\img\pipeline-comprehensions-2.png" alt="pipeline-comprehensions-2"></p>
<p>那么问题是，什么时候用 Comprehensions 更好呢？双方粉丝各有理解。</p>
<h2 id="嵌套操作符表达式">嵌套操作符表达式</h2><p>好处之一是你可以用集合操作来操作 collections。假设要使用表达式来找出那些 unoccupied red or blue rooms at the front of the hotel.</p>
<p><em>ruby</em></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">front</span> &amp; <span class="list">(<span class="keyword">red</span> | blue)</span>)</span> - occupied</span><br></pre></td></tr></table></figure>
<p><em>clojure</em></p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">difference</span></span></span><br><span class="line">    <span class="list">(<span class="keyword"><span class="built_in">intersection</span></span></span><br><span class="line">        <span class="list">(<span class="keyword"><span class="built_in">union</span></span> reds blues)</span></span><br><span class="line">        fronts)</span></span><br><span class="line">    occ)</span></span><br></pre></td></tr></table></figure>
<p><em>Clojure defines set operations on its set datatype, so all the symbols here are sets.</em></p>
<p>也可以用 collection pipelines 表达式的形式</p>
<p><em>ruby</em></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">red</span><br><span class="line">  .union(blue)</span><br><span class="line">  .intersect(front)</span><br><span class="line">  .diff(occupied)</span><br></pre></td></tr></table></figure>
<p><em>I monkey-patched Array to add the set operations as regular methods</em></p>
<p><em>clojure</em></p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">-&gt;&gt;</span></span> reds</span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">union</span></span> blues)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">intersection</span></span> fronts)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">remove</span></span> occ)</span>)</span></span><br></pre></td></tr></table></figure>
<p><em>I need clojure’s ‘remove’ method here in order to get the arguments in the right order for threading.</em></p>
<p>我更喜欢嵌套操作符表达式的形式，因为可以使用前缀操作符。当足够表达式复杂时也会和 pipes 一样一团乱。</p>
<p>也就是说，在 pipeline 中间用集合操作经常是有用的。假设颜色和位置时房间记录的属性，但是有客房间的列表是另一个 collection。</p>
<p><em>ruby</em></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rooms</span><br><span class="line">  .select&#123;|r| [<span class="symbol">:red</span>, <span class="symbol">:blue</span>].<span class="keyword">include</span>? r.color&#125;</span><br><span class="line">  .select&#123;|r| <span class="symbol">:front</span> == r.location&#125;</span><br><span class="line">  .diff(occupied)</span><br></pre></td></tr></table></figure>
<p><em>clojure</em></p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">-&gt;&gt;</span></span> <span class="list">(<span class="keyword">rooms</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">filter</span></span> #<span class="list">( #<span class="collection">&#123;<span class="attribute">:blue</span> <span class="attribute">:red</span>&#125;</span> <span class="list">(<span class="attribute">:color</span> %)</span>)</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">filter</span></span> #<span class="list">( #<span class="collection">&#123;<span class="attribute">:front</span>&#125;</span> <span class="list">(<span class="attribute">:location</span> %)</span>)</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword"><span class="built_in">remove</span></span> <span class="list">(<span class="keyword">set</span> <span class="list">(<span class="keyword">occupied</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p><em>Here I’m showing (set (occupied)) to show how we’d use a set wrapped over a collection as a predicate for the set membership in clojure.</em></p>
<p>尽管前缀操作符对于嵌套操作符表达式来说是不错，但是和 pipelines 不太合得来。</p>
<p><em>ruby</em></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">((rooms</span><br><span class="line">  .select&#123;|r| [<span class="symbol">:red</span>, <span class="symbol">:blue</span>].<span class="keyword">include</span>? r.color&#125;</span><br><span class="line">  .select&#123;|r| <span class="symbol">:front</span> == r.location&#125;</span><br><span class="line">  ) - occupied)</span><br><span class="line">  .map(&amp;<span class="symbol">:num</span>)</span><br><span class="line">  .sort</span><br></pre></td></tr></table></figure>
<p>另一个有关集合 (set) 操作符的想法是 collections 通常是有序的并且允许重复的列表。你必须非常清楚你使用的库里集合操作的真正含义。Clojure 会强迫你先把你的列表转换为集合 (set)。Ruby 会接受你传入的任意一个数组来进行集合操作，并自动保留顺序移除重复项。</p>
<h2 id="Laziness">Laziness</h2><p>Laziness 的概念源自函数式编程世界。动机可能是源自下面这样的代码：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">large_list</span><br><span class="line">    .map&#123;|e| slow_complex_method (e)&#125;</span><br><span class="line">    .take(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>这样的代码会花大部分时间在对每个元素计算 slow_complex_method 上，然后将除了 top 5 以外的结果全部丢弃。Laziness 允许底层平台发现你只需要5个结果，然后只对必要的项进行 slow_complex_method 运算。</p>
<p>这个的确是深入到了对运行时的使用，比如 slow_complex_method 的结果被 pipe 到 UI 的滚动菜单里的情形。一个 lazy pipeline 会仅仅在最终结果上调用 pipeline。</p>
<p>让 collection pipeline 变得 lazy，在建立时需要在构思中就带着 laziness。有些语言，通常是函数式语言比如 Clojure 和 Haskell，从开头就开始了。其他情形中，laziness 则可以被建立在特定一组 collection 类中 － Java 和 Ruby 有一些 lazy collection 的实现。</p>
<p>有些 pipeline 操作无法和 laziness 结合，必须运算整个列表。排序就是一例，不遍历整个列表是无法获取最大值的，尽管最大值只有一个。正经支持 laziness 的平台一般都会有有文档注明哪些操作时无法维持 laziness 的。</p>
<h2 id="并行_Parallelism">并行 Parallelism</h2><p>很多 pipeline 操作都天生可以并行调用。比如使用 map，对一个元素的计算结果不会受其他元素影响。所以假如程序运行在多核上，我可以通过多线程充分利用分布式 map 运算的优势。</p>
<p>很多平台都提供这种并行的分布式运算的能力。如果你在用一个复杂函数处理一个超大的集合，利用多核可能会有显著的性能提升。</p>
<p>然而并行化不一定总能提升性能。有可能你搭建并行环境的时间已经超过你从并行运算中能获得的时间收益里。因此，大多数平台都会显式的提供备选方案来让你选择是否使用并行化，比如 Clojure 的 pmap 就是 map 的并行版本。为了性能优化考虑，你应该用性能测试来确定是否真有性能方面的提升。</p>
<h2 id="不可变性">不可变性</h2><p>Collection-pipelines 天生就把自己交付给力了不可变的数据结构。当构建一个 pipeline 时，很自然的就会为每一个操作新建一个 collection 来放输出。简单的这么做涉及到很多的拷贝，一旦数据量巨大，很可能出问题。不过大部分时候都无需考虑这个问题。通常情况下，都是用几个指针而非真正的数据块。</p>
<p>一旦真成问题了，你可以使用那些专门来应对这种传递的数据结构来保持不变性。函数式语言趋向于使用可以用这种方式高效操纵的数据结构。</p>
<p>有必要的话，你也可以通过使用那些更新 collection 的操作来牺牲可变性。在非函数式编程的类库中同通常也会提供 collection pipeline operator 的破坏版本。我建议你仅在性能调节试验中使用它们。用不可变的操作吧，除非你已经明确遇到 pipeline 中的性能瓶颈了。</p>
<h2 id="调试">调试</h2><p>对于调试一个 collection pipeline，我有一堆问题。比如下面这个 ruby 程序：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> </span>get_readers_of_books1(readers, books, date)</span><br><span class="line">  data = <span class="variable">@data_service</span>.get_books_read_on(date)</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">    .select&#123;|k,v| readers.<span class="keyword">include</span>?(k)&#125;</span><br><span class="line">    .select&#123;|k,v| !(books &amp; v).empty?&#125;</span><br><span class="line">    .keys</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>现代IDE当然能帮上许多忙，不过还是假设我们在编辑器中且没有调试器。</p>
<p>我可能想要在 pipe 中间某一步获取些中间值。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> </span>get_readers_of_books2(readers, books, date)</span><br><span class="line">  data = <span class="variable">@data_service</span>.get_books_read_on(date)</span><br><span class="line">  temp = data</span><br><span class="line">    .select&#123;|k,v| readers.<span class="keyword">include</span>?(k)&#125;</span><br><span class="line">    .select&#123;|k,v| !(books &amp; v).empty?&#125;</span><br><span class="line">  pp temp</span><br><span class="line">  <span class="keyword">return</span> temp</span><br><span class="line">    .keys</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>还有一个比较 tricky 的做法是把输出语句也通过 map 弄到 pipeline 中。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> </span>get_readers_of_books(readers, books, date)</span><br><span class="line">  data = <span class="variable">@data_service</span>.get_books_read_on(date)</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">    .select&#123;|k,v| readers.<span class="keyword">include</span>?(k)&#125;</span><br><span class="line">    .select&#123;|k,v| !(books &amp; v).empty?&#125;</span><br><span class="line">    .map &#123;|e| pp e; e&#125;.to_h</span><br><span class="line">    .keys</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><em>In this case I need to convert back to a hash after the map operation</em></p>
<p>尽管可以帮助你知道代码在做些什么，但是可别忘了删了。</p>
<p>用一个好的调试器，你通常可以看到各个表达式的值。你只需要打好断点就可以看 pipe 的各个部分在发生些啥了。</p>
<h2 id="何时使用">何时使用</h2><p>作为一个范式，和其他范式一样有什么时候该用什么时候不用的问题。</p>
<p>第一个不该用的情形是，语言本身不支持。刚用 Java 时，老是试图在给对象加上一些操作来模拟这个范式，但最后代码往往一团糟也没有性能。因此我放弃了转而使用循环。尽管后来有一些函数式风格的库出现了，但是我还是觉得没有良好的 lambda 支持，运用这个范式还是会遇到许多麻烦。</p>
<p>另一个争论是，存在推导 (comprehension) 的情形，有推导可以更轻易的处理一些简单的表达式，不过处理复杂的你还是需要 pipeline 的。个人觉得 pipeline 和推导一样简单易懂，当然，这问题应该是团队定编程风格的时候考虑的。</p>
<p>即使语言支持，你也应当注意 pipeline 的大小，不要太大了，适当拆分并将一部分函数抽象出来。</p>
<p>Collection pipeline 是一种优秀的范式，一种所有程序员都了解的东西，在特别是 ruby 和 clojure 这样良好支持的语言中。也可以在很多情形下替代冗长的循环，增强可读性，易于改善。</p>
<h2 id="操作目录">操作目录</h2><p>下面是一些在 collection pipeline 中常见操作的目录。每种语言都选择了几个可用的操作，并且各自命名。但是我尝试根据功能梳理了一下。</p>
<ul>
<li><strong>collect</strong><br><em>同 map，源自 Smalltalk。Java8 则把 collect 用于完全不同的功能：一个将元素从 stream 里弄到 collections 里的终端。</em></li>
</ul>
<p>see map</p>
<ul>
<li><strong>distinct</strong></li>
</ul>
<p><img src="\img\pipeline-distinct.png" alt="pipeline-distinct"><br><em>去除重复项</em></p>
<ul>
<li><strong>flat-map</strong></li>
</ul>
<p><img src="\img\pipeline-flatmap.png" alt="pipeline-flatmap"><br><em>对 collection 应用 map，并展开一层。</em></p>
<ul>
<li><strong>group-by</strong></li>
</ul>
<p><img src="\img\pipeline-groupby.png" alt="pipeline-groupby"><br><em>对每个元素运行，并按照结果分组。</em></p>
<ul>
<li><strong>map</strong></li>
</ul>
<p><img src="\img\pipeline-map.png" alt="pipeline-map"><br><em>用给定的函数作用于输入的每一元素，并将结果放到输出中。</em></p>
<ul>
<li><strong>reject</strong><br><em>和 filter 相反，返回不符合判定的元素</em></li>
</ul>
<p>see filter</p>
<ul>
<li><strong>sort</strong></li>
</ul>
<p><img src="\img\pipeline-sort.png" alt="pipeline-sort"><br><em>输出是将输入排序后的结果，用指定的分隔符分隔。</em></p>
<ul>
<li><strong>concat</strong></li>
</ul>
<p><img src="\img\pipeline-concat.png" alt="pipeline-concat"><br><em>将多个 collections 串联成一个</em></p>
<ul>
<li><strong>drop</strong></li>
</ul>
<p><em>slice 的一种形式，返回除了前 n 个元素外的所有元素。</em></p>
<p>see slice</p>
<ul>
<li><strong>flatten</strong></li>
</ul>
<p><img src="\img\pipeline-flatten.png" alt="pipeline-flatten"><br><em>把 collection 里的嵌套去掉。</em></p>
<ul>
<li><strong>inject</strong></li>
</ul>
<p><em>reduce 的另一种命名，来自 Smalltalk 的 inject:into: 选择器。</em></p>
<ul>
<li><strong>mapcat</strong></li>
</ul>
<p><em>flat-map 的另一种命名</em></p>
<p>see flat-map</p>
<ul>
<li><strong>select</strong></li>
</ul>
<p><em>filter 的 另一种命名</em></p>
<ul>
<li><strong>take</strong></li>
</ul>
<p><em>slice 的一种形式，返回前 n 个元素</em></p>
<p>see slice</p>
<ul>
<li><strong>difference</strong></li>
</ul>
<p><img src="\img\pipeline-difference.png" alt="pipeline-difference"></p>
<ul>
<li><strong>filter</strong></li>
</ul>
<p><img src="\img\pipeline-filter.png" alt="pipeline-filter"><br><em>对每个元素运行一个布尔函数，把通过的放入输出中</em></p>
<ul>
<li><strong>fold</strong></li>
</ul>
<p><em>有些时候是 reduce 的另一种命名。常见为 foldl (fold-left) 和 flodr (fold-right)</em></p>
<ul>
<li><strong>intersection</strong></li>
</ul>
<p><img src="\img\pipeline-intersection.png" alt="pipeline-intersection"><br><em>保留同时出现在提供的 collections 里的元素</em></p>
<ul>
<li><strong>reduce</strong></li>
</ul>
<p><img src="\img\pipeline-reduce.png" alt="pipeline-reduce"><br><em>使用提供的函数将输入合并，通常情况下返回单个值</em></p>
<ul>
<li><strong>slice</strong></li>
</ul>
<p><img src="\img\pipeline-slice.png" alt="pipeline-slice"><br><em>给定列表的起始位置和结束位置，返回子序列</em></p>
<ul>
<li><strong>union</strong></li>
</ul>
<p><img src="\img\pipeline-union.png" alt="pipeline-union"><br><em>返回所有提供的 collections 的元素的去重后的列表</em></p>
<h2 id="Ref-">Ref.</h2><p><a href="http://martinfowler.com/articles/collection-pipeline/" target="_blank" rel="external">Collection Pipeline</a></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/07/13/String-immutable/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          从 String 讲 immutable 的重要性
        
      </div>
    </a>
  
  
    <a href="/2015/07/09/IOC-and-DI/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">控制反转和依赖注入［译］</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 evtHoriz
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>



<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-34664062-2', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>